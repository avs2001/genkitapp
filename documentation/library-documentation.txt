## File: ./projects/core/abstraction/error-state-matcher/error-state-matcher.txt

ErrorStateMatcher - Abstraction Documentation
Status: stable
Since: v1.0.0

Short description: A utility service that determines when form controls should display error states based on validation status and user interaction.

Purpose and Overview:
The ErrorStateMatcher abstraction provides a consistent way to determine when form controls should display error states across the application. It solves the problem of inconsistent error display logic by centralizing the error state determination in a single, injectable service. The service follows Angular's dependency injection pattern and implements a simple but effective logic: show errors when a control is invalid AND either touched by the user OR the form has been submitted. This prevents showing validation errors immediately when the user starts typing, providing a better user experience.

Quick Start:
  Import:
    import { ErrorStateMatcher } from '@kebormed/x-core/abstraction/error-state-matcher';

    @Component({
      // ...
    })
    export class MyFormComponent {
      constructor(private errorStateMatcher: ErrorStateMatcher) {}
    }

  Minimal usage (TypeScript):
    isFieldInError(control: NgControl, form: NgForm): boolean {
      return this.errorStateMatcher.isErrorState(control, form);
    }

Inputs and Outputs:
- Method: isErrorState(control: NgControl | AbstractControlDirective | null, form: FormGroupDirective | NgForm | null): boolean
  Description: Determines if a form control should display an error state. Returns true if the control exists, is invalid, and has been touched or the form has been submitted.

Slots and Content Projection:
Not applicable - this is a service abstraction, not a component with templates.

Styling and Theming:
Not applicable - this is a service abstraction that provides logic, not visual styling.

Accessibility:
The ErrorStateMatcher supports accessibility by providing consistent error state logic that can be used with ARIA attributes:
- Use the error state result to set aria-invalid="true" on form controls
- Combine with aria-describedby to associate error messages with form controls
- Ensures error states are announced to screen readers at appropriate times

Visual Examples:
Not applicable - this is a service abstraction that provides logic for determining error states, not visual components.

Behaviors and Lifecycle:
The ErrorStateMatcher is provided at the root level as a singleton service, making it available throughout the application. It has no internal state and performs stateless evaluation of form control states. The service implements the following logic:

1. Returns false if the control is null or undefined
2. Returns false if the control is valid
3. Returns true if the control is invalid AND (control is touched OR form is submitted)

This behavior ensures that:
- Errors are not shown immediately when a user starts interacting with a form
- Errors are shown after the user has interacted with a field (touched)
- Errors are shown for all invalid fields when the form is submitted
- The logic is consistent across all form components in the application

API Reference:
  Exports:
    export class ErrorStateMatcher {
      isErrorState(
        control: NgControl | AbstractControlDirective | null,
        form: FormGroupDirective | NgForm | null,
      ): boolean
    }

  Dependencies:
    - @angular/core (Injectable decorator)
    - @angular/forms (NgControl, AbstractControlDirective, FormGroupDirective, NgForm)

  Import Path:
    import { ErrorStateMatcher } from '@kebormed/x-core/abstraction/error-state-matcher';

Best Practices and Gotchas:
- Do: Use the ErrorStateMatcher consistently across all form components to ensure uniform error display behavior
- Do: Consider extending this class to create custom error state matchers for specific use cases
- Do: Inject the service in components that need to determine error states for form controls
- Do: Use the service result to control both visual error styling and ARIA attributes
- Don't: Implement custom error state logic in individual components when this service can be used
- Don't: Modify the core logic without considering the impact on user experience across the application
- Don't: Forget to handle null/undefined controls in your components before calling isErrorState

Migration Notes:
- v1.0.0: Initial release - no migration needed

Related Components / Patterns:
- Form validation components that need to display error states
- Input components with error state styling
- Form field wrappers that show/hide error messages
- Custom form controls that need consistent error state behavior
- Related utilities: @kebormed/x-core/utils/validation for async validation logic
- Related types: @kebormed/x-core/types for form-related type definitions

Changelog:
- v1.0.0: Initial release with basic error state matching logic

-----------------------------------------------------------

## File: ./projects/core/abstraction/field/field.txt

Field Control - Abstraction Documentation
Status: stable
Since: v1.0.0

Short description: Abstract base classes that provide a standardized interface for creating custom form field controls with seamless Angular Forms integration.

Purpose and Overview:
The Field Control abstraction solves the problem of creating consistent, reusable form field components that integrate seamlessly with Angular's reactive forms system. It provides two abstract classes: `FieldControl<T>` defines the basic interface for field controls, while `CustomFieldControl<T>` extends this with full `ControlValueAccessor` implementation. This abstraction ensures all custom form controls follow the same patterns for state management, validation, accessibility, and Angular Forms integration, reducing boilerplate code and maintaining consistency across the application.

Quick Start:
  Import:
    import { CustomFieldControl, FieldControl } from '@kebormed/x-core/abstraction/field';

  Minimal usage (TypeScript):
    @Component({
      selector: 'lib-custom-input',
      templateUrl: './custom-input.html',
      styleUrls: ['./custom-input.css'],
      changeDetection: ChangeDetectionStrategy.OnPush,
      providers: [
        {
          provide: NG_VALUE_ACCESSOR,
          useExisting: forwardRef(() => CustomInputComponent),
          multi: true
        }
      ]
    })
    export class CustomInputComponent extends CustomFieldControl<string> {
      value: string | undefined;

      writeValue(value: any): void {
        this.value = value;
        this.stateChanges.next();
      }

      onContainerClick(event: MouseEvent): void {
        // Handle container clicks (e.g., focus the input)
      }
    }

Inputs and Outputs:
- @Input() placeholder: string = ''
  Description: Sets the placeholder text displayed when the control is empty

- @Input() disabled: boolean = false
  Description: Controls whether the field is disabled. Uses booleanAttribute transform

- @Input() required: boolean = false
  Description: Indicates whether the field is required for form validation. Uses booleanAttribute transform

- @Input() id: string = auto-generated
  Description: Unique identifier for the control. Auto-generated using _IdGenerator with 'field-control-' prefix if not provided

- @Input() errorStateMatcher: ErrorStateMatcher | null = null
  Description: Custom error state matcher for determining when to display validation errors

Slots and Content Projection:
Not applicable for abstract classes. Content projection is handled by concrete implementations that extend these abstractions.

Styling and Theming:
Not applicable for abstract classes. Styling is implemented by concrete component implementations that extend these base classes. The abstractions provide the structural foundation for consistent theming across all field controls.

Accessibility:
- Keyboard: Abstract classes don't implement keyboard behavior directly. Concrete implementations should ensure proper keyboard navigation and focus management
- ARIA: The abstractions provide the foundation for ARIA integration through the `id` property and error state management. Concrete implementations should apply appropriate ARIA roles, states, and relationships
- Color contrast: Not applicable for abstract classes. Concrete implementations must ensure WCAG compliance

Visual Examples:
Not applicable for abstract classes. Visual examples are provided by concrete implementations that extend these base classes.

Behaviors and Lifecycle:
The `CustomFieldControl<T>` class implements Angular's `ControlValueAccessor` interface, providing seamless integration with reactive forms. Key behaviors include:

- State Management: Uses `stateChanges` Observable to notify when control state changes (placeholder, disabled, focused, etc.)
- Form Integration: Implements `registerOnChange`, `registerOnTouched`, and `setDisabledState` for Angular Forms compatibility
- Focus Tracking: Manages focus state and automatically calls `_onTouched` when focus changes
- Empty State Detection: Provides `empty` property using `kbmIsEmpty` utility to determine if the control's value is empty
- ID Generation: Automatically generates unique IDs using `_IdGenerator` service with 'field-control-' prefix
- Error State Management: Integrates with `ErrorStateMatcher` abstraction for consistent error display logic

API Reference:
  Exports:
    export abstract class FieldControl<T> {
      abstract value: T | T[] | undefined;
      abstract readonly stateChanges: Observable<void>;
      readonly ngControl: NgControl | AbstractControlDirective | null;
      abstract readonly required: boolean;
      abstract readonly disabled: boolean;
      abstract readonly focused: boolean;
      abstract readonly nativeControl: boolean;
      abstract readonly id: string;
      abstract readonly placeholder: string | undefined;
      abstract errorStateMatcher: ErrorStateMatcher | null;
      abstract readonly empty: boolean;
      abstract onContainerClick(event: MouseEvent): void;
    }

    export abstract class CustomFieldControl<T> implements FieldControl<T>, ControlValueAccessor {
      // Properties
      value: T | T[] | undefined; // Abstract - must be implemented
      readonly stateChanges: Subject<void>;
      readonly ngControl: NgControl;
      nativeControl: boolean = false;

      // Getters/Setters with Input decorators
      @Input() placeholder: string;
      @Input() errorStateMatcher: ErrorStateMatcher | null;
      @Input({transform: booleanAttribute}) disabled: boolean;
      @Input() id: string;
      @Input({transform: booleanAttribute}) required: boolean;
      focused: boolean; // Triggers stateChanges when set

      // Computed properties
      get empty(): boolean; // Uses kbmIsEmpty utility

      // ControlValueAccessor implementation
      registerOnChange(fn: any): void;
      registerOnTouched(fn: any): void;
      setDisabledState(isDisabled: boolean): void;
      abstract writeValue(obj: any): void; // Must be implemented
      abstract onContainerClick(event: MouseEvent): void; // Must be implemented
    }

Best Practices and Gotchas:
- Do: Extend `CustomFieldControl<T>` when creating custom form controls that need Angular Forms integration
- Do: Implement all required abstract methods (`writeValue`, `onContainerClick`, and `value` property)
- Do: Call `this.stateChanges.next()` whenever the control's state changes to notify subscribers
- Do: Set `this.focused = true/false` appropriately to trigger touched state and accessibility updates
- Do: Provide the component as a value accessor using `NG_VALUE_ACCESSOR` token in providers array
- Do: Use the `empty` property for consistent empty state detection across all field controls
- Don't: Forget to implement the abstract methods - TypeScript will enforce this but runtime errors may occur
- Don't: Manually manage the `ngControl` property - it's automatically set in the constructor
- Don't: Override the `empty` getter unless you have specific requirements different from `kbmIsEmpty`

Migration Notes:
No breaking changes since initial release. The abstraction is designed to be stable and backward-compatible.

Related Components / Patterns:
- ErrorStateMatcher (@kebormed/x-core/abstraction/error-state-matcher) - Used for consistent error state determination
- Angular ControlValueAccessor - Interface implemented by CustomFieldControl for forms integration
- _IdGenerator (@kebormed/x-core/utils/miscellaneous) - Utility for generating unique control IDs
- kbmIsEmpty (@kebormed/x-core/utils/miscellaneous) - Utility for determining empty values
- KbmNullable (@kebormed/x-core/types) - Type for nullable values used in error state matcher
- Input components that extend these abstractions for consistent form field behavior

Changelog:
- v1.0.0: Initial release with FieldControl and CustomFieldControl abstract classes

-----------------------------------------------------------

## File: ./projects/core/abstraction/form/form.txt

BaseForm - Abstract Class Documentation
Status: stable
Since: v1.0.0

Short description: An abstract base class that provides a standardized foundation for creating form components with consistent behavior, state management, and API.

Purpose and Overview:
The BaseForm abstract class solves the problem of form component consistency across Angular applications by providing a unified interface for form handling. It encapsulates common form functionality including edit mode tracking, form state access, error aggregation, and form control management. By extending this class, developers can create form components with predictable behavior while reducing code duplication and ensuring a uniform approach to form handling throughout the application. The class leverages Angular's reactive forms and dependency injection to provide a robust foundation for form implementations.

Quick Start:
  Import:
    import { BaseForm } from '@kebormed/x-core/abstraction/form';
    import { FormGroup, FormControl, Validators } from '@angular/forms';
    import { Component, output } from '@angular/core';

  Minimal usage (TypeScript):
    interface UserData {
      name: string;
      email: string;
    }

    @Component({
      selector: 'app-user-form',
      template: `
        <form [formGroup]="form">
          <input formControlName="name" placeholder="Name">
          <input formControlName="email" placeholder="Email">
          <button (click)="onSave()" [disabled]="!valid">Save</button>
        </form>
      `
    })
    export class UserFormComponent extends BaseForm<UserData> {
      form = new FormGroup({
        name: new FormControl('', Validators.required),
        email: new FormControl('', [Validators.required, Validators.email])
      });

      edit = output<Partial<UserData>>();
      save = output<UserData>();
      _previousValue: Partial<UserData> = {};

      get editData(): Partial<UserData> | null {
        return this._previousValue;
      }

      set editData(value: UserData | null) {
        if (value) {
          this._previousValue = { ...value };
          this.form.patchValue(value);
        }
      }

      onSave() {
        if (this.valid) {
          this.save.emit(this.value);
        }
      }
    }

Inputs and Outputs:
- Abstract Properties (must be implemented):
  form: FormGroup
  Description: The Angular FormGroup instance that manages the form controls

- edit: OutputEmitterRef<Partial<T>>
  Description: Output emitter for partial form data changes during editing

- save: OutputEmitterRef<T>
  Description: Output emitter for complete form data submission

- editData: getter/setter for Partial<T> | null
  Description: Gets or sets the data being edited, with appropriate type handling

- _previousValue: Partial<T>
  Description: Tracks the previous form values for comparison and rollback functionality

Slots and Content Projection:
Not applicable - this is an abstract class that provides functionality to extending components rather than template-based content projection.

Styling and Theming:
Not applicable - this abstract class does not provide styling. Styling is handled by the implementing components that extend this class.

Accessibility:
- The class provides unique ID generation for form elements through the injected _IdGenerator service
- Implementing components should use the provided `id` property for proper form labeling
- Form validation state is accessible through the `valid`, `errors`, `touched`, and `dirty` properties for ARIA state management

Visual Examples:
Not applicable - this is an abstract class. Visual examples would be provided by the concrete implementations that extend this class.

Behaviors and Lifecycle:
The BaseForm class manages several key behaviors:
- Automatic unique ID generation using the _IdGenerator service from @kebormed/x-core/utils/miscellaneous
- Edit mode state tracking through the isEdit property
- Form state aggregation providing easy access to validation, dirty state, and touch state
- Error aggregation that recursively collects errors from nested form controls
- Bulk field enabling/disabling through the setDisabled method
- Form value patching while maintaining form structure

Performance optimizations:
- Uses dependency injection for the _IdGenerator service to ensure singleton behavior
- Error aggregation is computed on-demand rather than being cached
- Form state properties are getters that delegate to the underlying FormGroup for real-time state

API Reference:
  Exports:
    export abstract class BaseForm<T = unknown> {
      // Abstract properties (must be implemented)
      abstract form: FormGroup;
      abstract edit: OutputEmitterRef<Partial<T>>;
      abstract save: OutputEmitterRef<T>;
      abstract get editData(): Partial<T> | null;
      abstract set editData(value: T | null);
      abstract _previousValue: Partial<T>;

      // Concrete properties
      protected _editMode: boolean = false;
      _id: string; // Auto-generated unique identifier

      // Getters and setters
      get id(): string;
      set isEdit(value: boolean);
      get isEdit(): boolean;
      get value(): T;
      get valid(): boolean;
      get errors(): any;
      get dirty(): boolean;
      get pristine(): boolean;
      get touched(): boolean;

      // Methods
      aggregateErrors(control: AbstractControl): any;
      setDisabled(fields: string[], disable: boolean): void;
      patchValue(value: Partial<T>): void;
    }

    Dependencies:
    - @angular/forms: AbstractControl, FormGroup
    - @angular/core: inject, OutputEmitterRef
    - @kebormed/x-core/utils/miscellaneous: _IdGenerator

Best Practices and Gotchas:
- Do: Implement all abstract properties and methods when extending BaseForm
- Do: Use the provided form state accessors (valid, dirty, etc.) instead of accessing form properties directly
- Do: Initialize _previousValue in your component to avoid null reference errors
- Do: Use the aggregateErrors method to get a structured view of all form errors
- Do: Use the unique id property for form element labeling and accessibility
- Don't: Modify the _id property as it's meant to be unique and auto-generated
- Don't: Forget to handle the case when editData is set to null
- Don't: Access form.value directly when the value getter provides the same functionality
- Don't: Create custom error aggregation logic when aggregateErrors provides this functionality

Migration Notes:
- v1.0.0: Initial release - no migration needed

Related Components / Patterns:
- Angular Reactive Forms: BaseForm is designed to work exclusively with Angular's reactive forms approach
- Form validation patterns: Use with custom validators and error handling strategies
- Form submission workflows: Integrate with API services for data persistence using the save output
- Error display components: Use the aggregated errors for consistent error presentation
- Edit/Create form patterns: Leverage the isEdit property and editData for dual-mode forms

Changelog:
- v1.0.0: Initial release with core form abstraction functionality

-----------------------------------------------------------

## File: ./projects/core/components/accordion/accordion.txt

Accordion - Component Documentation
Status: stable
Since: v1.0.0

Short description: A modern Angular accordion component that provides collapsible content panels for organizing information in a limited space.

Purpose and Overview:
The Accordion component solves the problem of displaying large amounts of content in a limited space by organizing it into collapsible panels. It allows users to expand and collapse sections of content, making it easier to navigate through information without overwhelming the user interface. The accordion component extends Angular CDK's CdkAccordion and CdkAccordionItem for optimal performance and accessibility, implementing keyboard navigation with FocusKeyManager and proper focus management with FocusMonitor. The component uses modern Angular patterns including standalone components, signals (contentChildren, contentChild, computed, input, viewChild), and the new control flow syntax (@if, @else, @for).

Quick Start:
  Import:
    import { KbmAccordion } from '@kebormed/x-core/components/accordion';
    @Component({
      imports: [KbmAccordion]
    })
    export class DemoComponent {}

  Minimal usage (HTML):
    <kbm-accordion>
      <kbm-accordion-item [title]="'Section 1'">
        Content for section 1
      </kbm-accordion-item>
      <kbm-accordion-item [title]="'Section 2'">
        Content for section 2
      </kbm-accordion-item>
    </kbm-accordion>

Inputs and Outputs:

AccordionComponent:
- @Input() multi: boolean = false
  Description: Sets whether multiple items can be expanded at the same time. When false (default), expanding one item will collapse others.

- @Input() id: string
  Description: Sets the unique identifier for the accordion. Inherited from CdkAccordion.

AccordionItemComponent:
- @Input() title: string | undefined
  Description: Sets the title text to display in the accordion item header. When provided, displays as simple text; when not provided, allows custom header template.

- @Input() disabled: boolean = false
  Description: Sets whether the accordion item is disabled. Inherited from CdkAccordionItem.

- @Input() expanded: boolean = false
  Description: Sets whether the accordion item is expanded. Inherited from CdkAccordionItem.

- @Output() opened: EventEmitter<void>
  Description: Fires when the accordion item is opened. Inherited from CdkAccordionItem.

- @Output() closed: EventEmitter<void>
  Description: Fires when the accordion item is closed. Inherited from CdkAccordionItem.

- @Output() expandedChange: EventEmitter<boolean>
  Description: Fires when the expanded state changes. Inherited from CdkAccordionItem.

Slots and Content Projection:
The accordion component supports the following content projection options:

AccordionComponent:
- Default content projection for <kbm-accordion-item> elements

AccordionItemComponent:
- Default content projection for accordion item content (when no kbmAccordionItemContent directive is used)
- Custom header template using the kbmAccordionItemHeader directive
- Custom content template using the kbmAccordionItemContent directive

Template reference variables:
- #accordionItem="accordionItem" - Provides access to AccordionItemComponent instance

Styling and Theming:
The accordion component can be customized using CSS custom properties:

- --kbm-accordion-item-height: 60px - Height of the accordion item header
- --kbm-accordion-border-color: #ccc - Border color of the accordion items
- --kbm-accordion-item-header-background: #f5f5f5 - Background color of the accordion item header
- --kbm-accordion-gap: 10px - Padding inside the accordion item header and content
- --kbm-accordion-title-color: #000 - Color of the accordion item title text
- --kbm-accordion-item-header-focus-background: #dfdede - Background color of the accordion item header when focused
- --kbm-accordion-item-content-background: #fff - Background color of the accordion item content
- --kbm-accordion-content-color: #000 - Color of the accordion item content text
- --kbm-accordion-item-radius: 8px - Border radius of the accordion items

Host classes:
- .is-multi - Applied when multi="true"
- .expanded - Applied to accordion items when expanded

Accessibility:
- Keyboard:
  * Enter/Space: Toggle expansion of the focused accordion item
  * Tab: Navigate between accordion items
  * Arrow keys: Navigate between accordion items with FocusKeyManager
  * Home/End: Navigate to first/last accordion item
- ARIA:
  * role="button" on accordion item headers for proper semantic meaning
  * aria-expanded attribute on accordion item headers indicating expansion state
  * role="region" on accordion item content for content area identification
  * aria-labelledby attribute on accordion item content linking to header
- Color contrast: Component follows WCAG guidelines with customizable color properties

Visual Examples:
Basic usage and variants:
  - Basic:
    <kbm-accordion>
      <kbm-accordion-item [title]="'Section 1'">
        Content for section 1
      </kbm-accordion-item>
      <kbm-accordion-item [title]="'Section 2'">
        Content for section 2
      </kbm-accordion-item>
    </kbm-accordion>

  - Variants / States:
    * Multiple expansion enabled:
      <kbm-accordion [multi]="true">
        <kbm-accordion-item [title]="'Section 1'">Content 1</kbm-accordion-item>
        <kbm-accordion-item [title]="'Section 2'">Content 2</kbm-accordion-item>
      </kbm-accordion>

    * Custom header and content templates:
      <kbm-accordion>
        <kbm-accordion-item>
          <ng-template kbmAccordionItemHeader>
            <div class="custom-header">
              <span>Custom Header</span>
              <span class="icon">🔽</span>
            </div>
          </ng-template>
          <ng-template kbmAccordionItemContent>
            <div class="custom-content">
              <p>Rich content with formatting</p>
              <button>Action Button</button>
            </div>
          </ng-template>
        </kbm-accordion-item>
      </kbm-accordion>

    * Disabled state:
      <kbm-accordion>
        <kbm-accordion-item [title]="'Disabled Item'" [disabled]="true">
          This content cannot be accessed
        </kbm-accordion-item>
      </kbm-accordion>

    * Pre-expanded state:
      <kbm-accordion>
        <kbm-accordion-item [title]="'Expanded Item'" [expanded]="true">
          This content is visible by default
        </kbm-accordion-item>
      </kbm-accordion>

Behaviors and Lifecycle:
The accordion component implements several key behaviors:
- Uses Angular CDK's CdkAccordion and CdkAccordionItem as base classes for consistent behavior
- Implements keyboard navigation using FocusKeyManager from Angular CDK with wrap and home/end support
- Uses FocusMonitor for proper focus handling and visual focus indicators
- Supports both single and multiple expansion modes through the multi input
- Provides template projection for both header and content customization
- Uses modern Angular signals for reactive state management (contentChildren, contentChild, computed, input, viewChild)
- Implements proper cleanup in ngOnDestroy to prevent memory leaks

Performance optimizations:
- Uses OnPush change detection strategy (inherited from CDK components)
- Leverages Angular signals for efficient reactivity
- Implements proper focus management to avoid unnecessary DOM queries

API Reference:
  Exports:
    export class AccordionComponent extends CdkAccordion implements AfterContentInit {
      multi: boolean;
      items: Signal<readonly AccordionItemComponent[]>;
      handleHeaderKeydown(event: KeyboardEvent): void;
      handleHeaderFocus(header: AccordionItemComponent): void;
    }

    export class AccordionItemComponent extends CdkAccordionItem implements FocusableOption, AfterViewInit, OnDestroy {
      readonly title: InputSignal<string | undefined>;
      readonly header: Signal<ElementRef<HTMLElement> | undefined>;
      readonly template: Signal<TemplateRef<any> | undefined>;
      readonly headerTemplate: Signal<TemplateRef<any> | undefined>;
      readonly hasContentTemplate: Signal<boolean>;
      readonly headerContext: { $implicit: CdkAccordionItem };
      focus(origin?: FocusOrigin, options?: FocusOptions): void;
    }

    export class AccordionItemHeaderDirective {}
    export class AccordionItemContentDirective {}

    export const KBM_ACCORDION: InjectionToken<AccordionComponent>;

    export const KbmAccordion = [
      AccordionComponent,
      AccordionItemComponent,
      AccordionItemHeaderDirective,
      AccordionItemContentDirective,
    ] as const;

Best Practices and Gotchas:
- Do: Use the accordion for organizing related content into collapsible sections
- Do: Consider using the multi input when users might need to compare information across sections
- Do: Provide clear and concise titles for accordion items
- Do: Use custom templates when you need rich header or content formatting
- Do: Test keyboard navigation to ensure accessibility compliance
- Don't: Use accordions for critical information that users must see immediately
- Don't: Nest accordions within accordions as it creates a confusing user experience
- Don't: Use accordions when all content needs to be visible at once
- Don't: Forget to handle the expanded state programmatically when needed

Migration Notes:
Not applicable as this is the initial version of the component.

Related Components / Patterns:
- Tabs: An alternative way to organize content into separate sections with horizontal navigation
- Expansion Panel: A similar component pattern that might offer more complex functionality
- Collapsible: A simpler version for single expandable content areas
- Card: Can be used in combination with accordion for elevated content presentation

Changelog:
- v1.0.0: Initial release

-----------------------------------------------------------

## File: ./projects/core/components/button/button.txt

Button - Component Documentation
Status: stable
Since: v1.0.0

Short description: A flexible button component that can be applied to button or anchor elements with support for icons, disabled states, and comprehensive theming.

Purpose and Overview:
The Button component provides a consistent, accessible, and themeable button implementation that can be applied as an attribute directive to both button and anchor elements. It handles disabled state management, event prevention when disabled, and supports icon placement with content projection. The component uses modern Angular patterns including OnPush change detection, ViewEncapsulation.None for global styling, and the inject() function for dependency injection. It also provides an injection token (KBM_BUTTON) for component access and includes a companion IconButtonDirective for icon-only button variants.

Quick Start:
  Import:
    import { ButtonComponent, IconButtonDirective } from '@kebormed/x-core/components/button';

    @Component({
      imports: [ButtonComponent, IconButtonDirective]
    })
    export class DemoComponent {}

  Minimal usage (HTML):
    <button kbm-button>Click me</button>
    <a kbm-button href="/link">Link Button</a>

Inputs and Outputs:
- @Input() disabled: boolean = false
  Description: Controls the disabled state of the button. Uses booleanAttribute transform to handle string/boolean conversion. When true, prevents click events and applies disabled styling.

Slots and Content Projection:
The component supports sophisticated content projection for icons and text:
- Default content: Projected into a <span class="label"> wrapper (unless it's an icon button)
- kbm-icon:not([end]): Icons placed at the start of the button
- kbm-icon[end]: Icons placed at the end of the button
- Icon-only buttons: When using IconButtonDirective, the label wrapper is omitted

Template structure:
```html
<ng-content select="kbm-icon:not([end])" />
@if (!isIconButton) {
  <span class="label"><ng-content /></span>
}
<ng-content select="kbm-icon[end]" />
```

Styling and Theming:
The component uses an extensive CSS custom properties system for theming:

Core Properties:
- --kbm-button-margin: Button margin (default: 0)
- --kbm-button-radius: Border radius (default: 900px for pill shape)
- --kbm-button-height: Button height (default: 30px)
- --kbm-button-background: Background color (default: transparent)
- --kbm-button-text-color: Text color (default: #000)
- --kbm-button-border-width: Border width (default: 1px)
- --kbm-button-border-color: Border color (default: #000)
- --kbm-button-text-decoration: Text decoration (default: none)

Font Properties:
- --kbm-button-font-family: Font family (default: sans-serif)
- --kbm-button-font-size: Font size (default: 1rem)
- --kbm-button-font-weight: Font weight (default: 400)

State-specific Properties:
- --kbm-button-disabled-background: Disabled background (default: #ccc)
- --kbm-button-disabled-border-color: Disabled border color (default: #ccc)
- --kbm-button-disabled-text-color: Disabled text color (default: #000)
- --kbm-button-focus-background: Hover/focus background (default: #ccc)
- --kbm-button-focus-border-color: Hover/focus border color (default: #ccc)
- --kbm-button-focus-text-color: Hover/focus text color (default: #000)

The component includes smooth transitions (0.25s linear) for background-color, border-color, and color properties.

Accessibility:
- Keyboard: Maintains native button/anchor keyboard behavior and focus management
- ARIA: Uses native button/anchor semantics; disabled state is communicated via the disabled attribute
- Color contrast: Theming system allows for WCAG-compliant color combinations through CSS custom properties
- Focus management: Proper focus indicators through :focus pseudo-class styling

Visual Examples:
Basic usage and variants:
  - Basic Button:
    <button kbm-button>Basic Button</button>

  - Link Button:
    <a kbm-button href="/example">Link Button</a>

  - Disabled Button:
    <button kbm-button [disabled]="true">Disabled Button</button>

  - Button with Start Icon:
    <button kbm-button>
      <kbm-icon>home</kbm-icon>
      Home
    </button>

  - Button with End Icon:
    <button kbm-button>
      Next
      <kbm-icon end>arrow_forward</kbm-icon>
    </button>

  - Icon-only Button:
    <button kbm-button kbmIconButton>
      <kbm-icon>settings</kbm-icon>
    </button>

Behaviors and Lifecycle:
The component implements OnInit and OnDestroy lifecycle hooks to manage event listeners:
- OnInit: Adds a click event listener (outside Angular zone for performance) that prevents event propagation when the button is disabled
- OnDestroy: Removes the click event listener to prevent memory leaks
- Uses kbmInjectElement() utility from @kebormed/x-core/utils/dom for direct DOM access instead of ElementRef
- Leverages NgZone.runOutsideAngular() for performance optimization of event handling

API Reference:
  Exports:
    export class ButtonComponent implements OnInit, OnDestroy {
      @Input({transform: booleanAttribute}) disabled: boolean;
      isIconButton: boolean;
    }

    export class IconButtonDirective {
      // Modifies button behavior for icon-only buttons
    }

    export const KBM_BUTTON = new InjectionToken<ButtonComponent>('KBM_BUTTON');

  Import Path:
    import { ButtonComponent, IconButtonDirective, KBM_BUTTON } from '@kebormed/x-core/components/button';

Best Practices and Gotchas:
- Do: Use the component as an attribute directive on button or anchor elements
- Do: Leverage the CSS custom properties system for consistent theming
- Do: Use the IconButtonDirective for icon-only buttons to ensure proper styling
- Do: Use the KBM_BUTTON injection token when you need to access the button instance from child components
- Don't: Apply the directive to elements other than button or anchor tags
- Don't: Forget to handle the disabled state in your click handlers (the component prevents events, but you should also check the state)
- Don't: Override the component's event prevention logic - it's designed to work with the disabled state

Migration Notes:
- v1.0.0: Initial release with attribute directive approach
- The component uses modern Angular patterns (standalone components, inject() function, OnPush change detection)
- Uses ViewEncapsulation.None to allow global styling through CSS custom properties

Related Components / Patterns:
- IconButtonDirective: Companion directive for icon-only button variants
- Icon Component (kbm-icon): Used for button icons with proper positioning
- Card Component: Buttons are commonly used within card actions
- Form Components: Buttons are essential for form submission and actions
- Material Design Button: Similar concept but with Kebormed-specific styling and behavior

Changelog:
- v1.0.0: Initial release with attribute directive approach, theming system, and icon support

-----------------------------------------------------------

## File: ./projects/core/components/calendar/calendar.txt

Calendar - Component Documentation
Status: stable
Since: v1.0.0

Short description: A flexible and accessible date picker component for selecting single dates or date ranges with navigation controls.

Purpose and Overview:
The Calendar component provides a user-friendly interface for date selection that supports both single date and date range selection modes. It solves the problem of inconsistent date picking experiences by offering a unified, keyboard-accessible calendar widget with month/year navigation controls. The component is built with modern Angular features including standalone architecture, signals for reactive state management, and OnPush change detection for optimal performance. It integrates with the DateAdapter service for internationalization support and uses the DateRange type from @kebormed/x-core/types for consistent date range handling across the application.

Quick Start:
  Import:
    import { CalendarComponent } from '@kebormed/x-core/components/calendar';

    @Component({
      imports: [CalendarComponent]
    })
    export class DemoComponent {}

  Minimal usage (HTML):
    <!-- Single date selection -->
    <kbm-calendar [date]="selectedDate" (dateChange)="onDateChange($event)"></kbm-calendar>

    <!-- Date range selection -->
    <kbm-calendar [date]="dateRange" [isRange]="true" (dateChange)="onDateRangeChange($event)"></kbm-calendar>

    <!-- With min/max constraints -->
    <kbm-calendar
      [date]="selectedDate"
      [min]="minDate"
      [max]="maxDate"
      (dateChange)="onDateChange($event)">
    </kbm-calendar>

Inputs and Outputs:
- @Input() date: Date | DateRange | null = null
  Description: Sets the currently selected date or date range. For single date mode, pass a Date object. For range mode, pass a DateRange object with start and end properties.

- @Input() isRange: boolean = false
  Description: Enables date range selection mode. When true, users can select a start and end date to create a range.

- @Input() min: Date
  Description: Sets the minimum selectable date. Dates before this value will be disabled and unselectable.

- @Input() max: Date
  Description: Sets the maximum selectable date. Dates after this value will be disabled and unselectable.

- @Output() dateChange: EventEmitter<Date | DateRange>
  Description: Emitted when the selected date or date range changes. In single date mode, emits a Date object. In range mode, emits a DateRange object when both start and end dates are selected.

Slots and Content Projection:
The Calendar component does not support content projection. All UI elements are internally managed including navigation controls, month/year selectors, and the calendar grid.

Styling and Theming:
- Calendar Component Variables:
  * --kbm-calendar-width: Controls the width of the calendar container
  * --kbm-calendar-day-color: Controls the color of SVG navigation icons and day text

- Month View Variables:
  * --kbm-calendar-week-day-bg: Background color of weekday headers
  * --kbm-calendar-week-day-color: Text color of weekday headers
  * --kbm-calendar-week-day-font-size: Font size of weekday headers
  * --kbm-calendar-week-day-font-weight: Font weight of weekday headers
  * --kbm-calendar-day-font-size: Font size of day numbers
  * --kbm-calendar-focus-day-bg: Background color of focused day
  * --kbm-calendar-focus-day-color: Text color of focused day
  * --kbm-calendar-today-color: Text color of today's date
  * --kbm-calendar-today-border-color: Border color of today's date
  * --kbm-calendar-active-day-bg: Background color of selected day
  * --kbm-calendar-active-day-color: Text color of selected day
  * --kbm-calendar-in-range-day-bg: Background color of days within selected range
  * --kbm-calendar-in-range-day-color: Text color of days within selected range
  * --kbm-calendar-disabled-day-bg: Background color of disabled days
  * --kbm-calendar-disabled-day-color: Text color of disabled days

- Responsive behavior: The calendar maintains consistent sizing across different screen sizes and adapts to container constraints.

Accessibility:
- Keyboard: Arrow keys navigate between days, Enter/Space selects a date, Escape cancels range selection. Tab navigation moves between navigation controls and calendar grid.
- ARIA: Appropriate ARIA attributes are applied for screen readers including role="grid" for the calendar, proper labeling of navigation buttons, and date cell descriptions.
- Color contrast: All interactive elements meet WCAG AA contrast requirements. Disabled states are clearly distinguishable through both color and visual indicators.

Visual Examples:
Basic usage and variants:
  - Basic Single Date Calendar
    Standard calendar for selecting a single date with month/year navigation
  - Date Range Calendar
    Calendar configured for selecting start and end dates with range highlighting
  - Calendar with Constraints
    Calendar with minimum and maximum date restrictions showing disabled dates
  - Different States:
    * Normal selection state
    * Range selection in progress (start date selected)
    * Completed range selection
    * Disabled/constrained dates

Behaviors and Lifecycle:
The Calendar component consists of two main parts: the CalendarComponent handles date selection logic and navigation controls, while the MonthViewComponent renders the calendar grid. The component uses OnPush change detection strategy for optimal performance and leverages Angular's modern features including the output() function for event emission and viewChild() for accessing child components. The component integrates with the DateAdapter service for date manipulation, enabling internationalization support and different calendar systems. Internal state management uses private properties with getter/setter patterns for inputs, and the component automatically handles range selection logic including start/end date ordering.

API Reference:
  Exports:
    export class CalendarComponent {
      @Input() date: Date | DateRange | null;
      @Input() isRange: boolean;
      @Input() min: Date;
      @Input() max: Date;
      @Output() dateChange: EventEmitter<Date | DateRange>;

      // Navigation methods
      previousMonth(): void;
      nextMonth(): void;
      previousYear(): void;
      nextYear(): void;

      // Utility methods
      focusActiveCell(): void;
      handleValueChange(date: Date): void;
      handleSelectMonth(month: string | number): void;
      handleSelectYear(year: string | number): void;
    }

    export class CalendarUtils {
      createHeader(): string[];
      createCalendar(dateRef: Date): Array<(Date | null)[]>;
    }

    // Related types from @kebormed/x-core/types
    export interface DateRange {
      start: Date | null;
      end: Date | null;
    }

Best Practices and Gotchas:
- Do: Provide a DateAdapter implementation in your application for the component to function correctly
- Do: Use the isRange input to enable date range selection when needed
- Do: Set min and max dates to restrict selectable ranges when appropriate
- Do: Handle the dateChange event to capture and process user selections
- Do: Use the DateRange type from @kebormed/x-core/types for consistent typing
- Don't: Forget to import the DateAdapter provider in your application module
- Don't: Modify the date input directly without handling the dateChange event
- Don't: Use the component without proper keyboard navigation testing for accessibility

Migration Notes:
Not applicable for the initial release. Future versions will include migration guidance for any breaking changes to the API or behavior.

Related Components / Patterns:
- DateAdapter: Required service for date manipulation and internationalization support
- DateRange: Interface from @kebormed/x-core/types for representing date ranges
- MonthViewComponent: Internal component that renders the calendar grid
- DatePicker: Higher-level component that uses Calendar for date input fields
- KBM_DATE_FORMAT token: Optional injection token from @kebormed/x-core/tokens for custom date formatting

Changelog:
- v1.0.0: Initial release with single date and date range selection support

-----------------------------------------------------------

## File: ./projects/core/components/card/card.txt

Card - Component Documentation
Status: stable
Since: v1.0.0

Short description: A flexible card component system that provides structured content containers with header, content, and footer sections.

Purpose and Overview:
The Card component system provides a comprehensive solution for displaying structured content in card layouts. It consists of a main card container component and several sub-components (header, content, footer) along with utility directives (title, image) that work together to create flexible, reusable card interfaces. The component uses CSS custom properties for theming and supports content projection for maximum flexibility. The design follows modern Angular patterns with standalone components, OnPush change detection, and host bindings for CSS classes.

Quick Start:
  Import:
    import { KbmCard } from '@kebormed/x-core/components/card';
    // Or import individual components
    import {
      CardComponent,
      CardHeaderComponent,
      CardContentComponent,
      CardFooterComponent,
      CardTitleDirective,
      CardImageDirective
    } from '@kebormed/x-core/components/card';

    @Component({
      imports: [KbmCard] // Imports all card components and directives
      // Or import individually: [CardComponent, CardHeaderComponent, ...]
    })
    export class DemoComponent {}

  Minimal usage (HTML):
    <kbm-card>
      <kbm-card-header>Header content</kbm-card-header>
      <kbm-card-content>Main content</kbm-card-content>
      <kbm-card-footer>Footer content</kbm-card-footer>
    </kbm-card>

Inputs and Outputs:

Main Card Component (CardComponent):
- No inputs or outputs (pure container component)

Card Footer Component (CardFooterComponent):
- @Input() end: boolean = false
  Description: When true, aligns footer content to the right (flex-end). Uses coerceBooleanProperty transform for type safety.

Card Header Component (CardHeaderComponent):
- No inputs or outputs (pure container component)

Card Content Component (CardContentComponent):
- No inputs or outputs (pure container component)

Card Title Directive (CardTitleDirective):
- No inputs or outputs (styling directive only)

Card Image Directive (CardImageDirective):
- No inputs or outputs (styling directive only)

Slots and Content Projection:
The card component uses structured content projection with specific selectors:
- Header slot: Projects content with selector "kbm-card-header"
- Content slot: Projects content with selectors "kbm-card-content", "[kbmCardTitle]", "[kbmCardImage]"
- Footer slot: Projects content with selector "kbm-card-footer"

Content placement options:
- Use <kbm-card-header> for header content
- Use <kbm-card-content> for main content area
- Use [kbmCardTitle] directive on any element for styled titles
- Use [kbmCardImage] directive on images for proper styling
- Use <kbm-card-footer> for footer content with optional end alignment

Styling and Theming:
CSS custom properties exposed for theming:
- --kbm-card-bg: Background color (default: #fff)
- --kbm-card-border-radius: Border radius (default: 20px)
- --kbm-card-box-shadow: Box shadow (default: 0 0 10px rgba(0, 0, 0, 0.1))
- --kbm-card-hover-box-shadow: Hover box shadow (default: 0 6px 12px rgba(0, 0, 0, 0.15))
- --kbm-card-border: Border style (default: 1px solid #ccc)
- --kbm-card-padding: Padding for content areas (default: 10px)
- --kbm-card-content-color: Content text color (default: #000)
- --kbm-card-footer-bg: Footer background (default: transparent)
- --kbm-card-footer-color: Footer text color (default: #000)
- --kbm-card-header-bg: Header background (default: transparent)
- --kbm-card-title-color: Title text color (default: #000)
- --kbm-card-title-font-size: Title font size (default: 1.5rem)
- --kbm-card-title-font-weight: Title font weight (default: bold)

Composition tips:
- Cards are flex containers with column direction
- Content area grows to fill available space (flex-grow: 1)
- Images are constrained to container size (max-width/height: 100%)
- Hover effects are built-in with smooth transitions

Responsive behavior:
- Cards adapt to container width
- Images scale responsively within constraints
- Flexible layout adjusts to content

Accessibility:
- Keyboard: Standard focus behavior for interactive content within cards
- ARIA: No specific ARIA roles applied by default - add appropriate roles based on card content
- Color contrast: Uses CSS custom properties allowing WCAG compliant color schemes
- Semantic structure: Uses div elements - consider wrapping in semantic elements (article, section) based on content

Visual Examples:
Basic usage and variants:
  - Basic card with all sections:
    <kbm-card>
      <kbm-card-header>Card Title</kbm-card-header>
      <kbm-card-content>
        <p>Card content goes here</p>
      </kbm-card-content>
      <kbm-card-footer>Footer actions</kbm-card-footer>
    </kbm-card>

  - Card with title directive:
    <kbm-card>
      <kbm-card-content>
        <h2 kbmCardTitle>Styled Title</h2>
        <p>Content with styled title</p>
      </kbm-card-content>
    </kbm-card>

  - Card with image:
    <kbm-card>
      <kbm-card-content>
        <img kbmCardImage src="image.jpg" alt="Description">
        <p>Content with image</p>
      </kbm-card-content>
    </kbm-card>

  - Card with right-aligned footer:
    <kbm-card>
      <kbm-card-content>Content</kbm-card-content>
      <kbm-card-footer [end]="true">
        <button>Action</button>
      </kbm-card-footer>
    </kbm-card>

Behaviors and Lifecycle:
- Uses OnPush change detection strategy for optimal performance
- ViewEncapsulation.None on main card component allows global styling
- Host bindings automatically apply CSS classes
- Smooth hover transitions (0.3s ease) for enhanced user experience
- Content projection happens during Angular's content initialization phase

API Reference:
  Exports:
    export class CardComponent {}
    export class CardHeaderComponent {}
    export class CardContentComponent {}
    export class CardFooterComponent {
      @Input({transform: coerceBooleanProperty}) end = false;
    }
    export class CardTitleDirective {}
    export class CardImageDirective {}
    export const KbmCard = [
      CardComponent,
      CardContentComponent,
      CardFooterComponent,
      CardHeaderComponent,
      CardTitleDirective,
      CardImageDirective
    ] as const;

  Import paths:
    - Individual imports: '@kebormed/x-core/components/card'
    - Barrel import: '@kebormed/x-core/components/card' (KbmCard array)

Best Practices and Gotchas:
- Do: Use the KbmCard barrel export to import all components at once
- Do: Leverage CSS custom properties for consistent theming
- Do: Use semantic HTML elements within card content for accessibility
- Do: Apply appropriate ARIA roles based on card content purpose
- Don't: Override the flex layout properties without understanding the impact
- Don't: Forget to import the necessary components when using individual imports
- Don't: Apply conflicting styles that might break the card's responsive behavior

Migration Notes:
- v1.0.0: Initial release with standalone components
- Components use modern Angular patterns (standalone, OnPush, host bindings)
- CSS custom properties provide flexible theming without breaking changes

Related Components / Patterns:
- Similar to Material Design Card component
- Works well with button components for actions
- Can be combined with list components for card collections
- Follows container/content projection patterns common in design systems
- Compatible with Angular CDK layout utilities

Changelog:
- v1.0.0: Initial release with CardComponent, CardHeaderComponent, CardContentComponent, CardFooterComponent, CardTitleDirective, and CardImageDirective

-----------------------------------------------------------

## File: ./projects/core/components/carousel/carousel.txt

Carousel - Component Documentation
Status: stable
Since: v1.0.0

Short description: A customizable carousel component for displaying a collection of items with auto-scrolling capabilities and manual navigation.

Purpose and Overview:
The Carousel component provides a way to display a collection of items in a horizontally scrolling container. It supports auto-scrolling with configurable duration, manual navigation via next/prev methods, mouse wheel scrolling, and responsive display options. The component uses modern Angular features including signals for reactive state management, standalone components, and the new control flow syntax. It automatically pauses auto-scrolling when the user interacts with the carousel (hover, touch) or when the page becomes hidden, providing an optimal user experience.

Quick Start:
  Import:
    import { CarouselComponent, CarouselItemDirective } from '@kebormed/x-core/components/carousel';

    @Component({
      imports: [CarouselComponent, CarouselItemDirective]
    })
    export class DemoComponent {}

  Minimal usage (HTML):
    <kbm-carousel [display]="3" [duration]="4000">
      <p *kbmCarouselItem>Item 1</p>
      <p *kbmCarouselItem>Item 2</p>
      <p *kbmCarouselItem>Item 3</p>
      <p *kbmCarouselItem>Item 4</p>
      <p *kbmCarouselItem>Item 5</p>
    </kbm-carousel>

Inputs and Outputs:
- @Input() display: number = 1
  Description: Sets the number of items to display at once in the carousel viewport. Controls how many items are visible simultaneously.

- @Input() index: number = 0
  Description: Sets the starting index of the carousel. Determines which item group is initially visible.

- @Input() duration: number (via CarouselAutoScrollDirective)
  Description: Sets the auto-scroll interval in milliseconds. When provided, enables automatic progression through carousel items.

Slots and Content Projection:
The carousel uses content projection to display items. Each item should be marked with the `*kbmCarouselItem` structural directive:

<kbm-carousel>
  <div *kbmCarouselItem>Content for item 1</div>
  <div *kbmCarouselItem>Content for item 2</div>
  <div *kbmCarouselItem>Content for item 3</div>
</kbm-carousel>

The component supports any HTML content within carousel items and automatically manages their layout and positioning.

Styling and Theming:
- CSS custom properties:
  - `--duration`: Controls transition duration (default: 300ms)
- The carousel items are displayed in a flex container with equal width based on the `display` input
- Items have default padding of 1.25rem on left and right
- The carousel has overflow hidden to ensure only the visible items are shown
- Smooth transitions are applied when the `.animate` class is present on the host element
- Responsive behavior: Items automatically adjust their width based on the `display` value

Accessibility:
- Keyboard: The component supports programmatic navigation via next() and prev() methods
- ARIA: The carousel has `role="region"` and `aria-roledescription="carousel"`. The wrapper has `role="list"` and each item has `role="listitem"`
- Color contrast: No specific color styling applied, inherits from parent context

Visual Examples:
Basic usage and variants:
  - Basic Carousel:
    <kbm-carousel [display]="3">
      <div *kbmCarouselItem>Item 1</div>
      <div *kbmCarouselItem>Item 2</div>
      <div *kbmCarouselItem>Item 3</div>
      <div *kbmCarouselItem>Item 4</div>
      <div *kbmCarouselItem>Item 5</div>
    </kbm-carousel>

  - Auto-scrolling Carousel:
    <kbm-carousel [display]="3" [duration]="3000">
      <div *kbmCarouselItem>Item 1</div>
      <div *kbmCarouselItem>Item 2</div>
      <div *kbmCarouselItem>Item 3</div>
      <div *kbmCarouselItem>Item 4</div>
      <div *kbmCarouselItem>Item 5</div>
    </kbm-carousel>

  - Manual Navigation:
    <kbm-carousel #carousel="kbmCarousel" [display]="3">
      <div *kbmCarouselItem>Item 1</div>
      <div *kbmCarouselItem>Item 2</div>
      <div *kbmCarouselItem>Item 3</div>
    </kbm-carousel>
    <button (click)="carousel.prev()">Previous</button>
    <button (click)="carousel.next()">Next</button>

Behaviors and Lifecycle:
- The carousel uses Angular signals for reactive state management
- Auto-scrolling automatically pauses when:
  - The user hovers over the carousel
  - The user touches the carousel (on touch devices)
  - The page becomes hidden (using PAGE_VISIBILITY token)
- Auto-scrolling resumes when:
  - The user's mouse leaves the carousel
  - The user stops touching the carousel
  - The page becomes visible again
- The carousel supports manual navigation via the `next()` and `prev()` methods
- Mouse wheel scrolling is supported through the CarouselScrollDirective
- The component implements OnInit to subscribe to item changes
- Uses OnPush change detection strategy for optimal performance

API Reference:
  Exports:
    export class CarouselComponent implements OnInit {
      display = input<number>(1);
      index = input<number>(0);
      readonly items: QueryList<CarouseItem>;
      transform = computed(() => string);

      public next(): void;
      public prev(): void;
      onScroll(delta: number): void;
      onAutoscroll(): void;
      getStyle(itemsCount: number): Partial<CSSStyleDeclaration>;
    }

    export class CarouselItemDirective {
      public readonly tpl: TemplateRef<unknown>;
    }

    export class CarouselDirective extends Observable<unknown> {
      @Input() set duration(duration: number);
    }

    export class CarouselAutoScrollDirective {
      @Output() readonly kbmCarouselAutoScroll;
    }

    export class CarouselScrollDirective {
      @Output() readonly kbmCarouselScroll;
    }

    export interface CarouseItem {
      tpl: TemplateRef<any>;
    }

    export const CAROUSEL_ITEM: InjectionToken<CarouseItem>;

Best Practices and Gotchas:
- Do: Use the carousel for displaying collections of related items
- Do: Provide appropriate `display` values based on your content and viewport size
- Do: Use template reference variables to access carousel methods for manual navigation
- Do: Consider accessibility when implementing custom navigation controls
- Don't: Put too many items in the carousel as it may affect performance
- Don't: Use extremely short duration values for auto-scrolling as it may cause motion sickness
- Don't: Forget to handle responsive behavior for different screen sizes

Migration Notes:
- v1.0.0: Initial release with modern Angular features (signals, standalone components, new control flow)

Related Components / Patterns:
- Similar to Material Design Carousel/Slider components
- Can be combined with pagination components for large datasets
- Works well with card components for structured content display
- Related to tab components for content organization

Changelog:
- v1.0.0: Initial release with auto-scrolling, manual navigation, and responsive display capabilities

-----------------------------------------------------------

## File: ./projects/core/components/confirmation/confirmation.txt

Confirmation - Component Documentation
Status: stable
Since: v1.0.0

Short description: A confirmation dialog system that provides modal dialogs for user confirmation with customizable messages and configurable options.

Purpose and Overview:
The Confirmation component provides a complete solution for displaying confirmation dialogs in Angular applications. It consists of a service-based approach using Angular CDK Overlay for modal management, a container component for the dialog UI, a directive for easy integration, and configurable options through dependency injection. The system supports both string messages and custom template references, includes accessibility features like focus trapping, and provides a clean API for handling user responses through observables.

Quick Start:
  Import:
    import { ConfirmationService, ConfirmDirective, KBM_CONFIRMATION_OPTIONS } from '@kebormed/x-core/components/confirmation';
    import type { ConfirmationOptions } from '@kebormed/x-core/components/confirmation';

  Minimal usage (Service):
    @Component({
      // ...
    })
    export class MyComponent {
      private confirmationService = inject(ConfirmationService);

      onDelete() {
        this.confirmationService.open('Are you sure you want to delete this item?')
          .subscribe(confirmed => {
            if (confirmed) {
              // Perform delete action
            }
          });
      }
    }

  Minimal usage (Directive):
    <button kbmConfirm message="Are you sure?" (kbmConfirm)="onConfirm($event)">
      Delete Item
    </button>

Inputs and Outputs:

ConfirmDirective:
- @Input() message: string | TemplateRef<ContextWithImplicit<ConfirmationRef>> | undefined
  Description: The confirmation message to display. Can be a string or a template reference for custom content.

- @Output() kbmConfirm: EventEmitter<boolean>
  Description: Emits the user's confirmation choice - true for positive action, false for negative action.

Slots and Content Projection:
The confirmation dialog supports custom templates through TemplateRef inputs. When using a template, the ConfirmationRef is provided as the implicit context ($implicit), allowing access to the dialog reference for custom close actions.

Template Context:
- $implicit: ConfirmationRef - The dialog reference for programmatic control

Styling and Theming:
- CSS classes: .kbm-confirmation-container, .kbm-confirmation, .confirm-button-positive, .confirm-button-negative
- The dialog uses the card component system for consistent styling
- Responsive behavior: Centered overlay with configurable width
- Default width: 400px (configurable via KBM_CONFIRMATION_OPTIONS)

Accessibility:
- Keyboard: Focus is trapped within the dialog using CDK's CdkTrapFocus
- ARIA: Proper modal dialog semantics through CDK Overlay
- Focus management: Initial focus is set automatically when dialog opens
- Backdrop: Click-to-close behavior with proper overlay management

Visual Examples:
Basic usage and variants:
  - Basic string message confirmation
  - Custom template with complex content
  - Configurable button labels and styling
  - Overlay positioning and backdrop behavior

Behaviors and Lifecycle:
- Service creates overlay instances on demand
- Focus trapping is activated on dialog open (ngAfterViewInit)
- Dialog closes automatically when user makes a choice
- Observable completes after emitting the result
- Overlay is properly disposed to prevent memory leaks
- Uses takeUntilDestroyed for automatic subscription cleanup in directive

API Reference:
  Exports:
    export class ConfirmationService {
      open(message?: string | TemplateRef<ContextWithImplicit<ConfirmationRef>>): Observable<boolean>
    }

    export class ConfirmDirective implements ConfirmationMessage {
      @Input() message: string | TemplateRef<ContextWithImplicit<ConfirmationRef>> | undefined;
      kbmConfirm: OutputEmitterRef<boolean>;
    }

    export class ConfirmationRef<T = unknown> {
      readonly closed: Observable<T>;
      close(reason: T): void;
    }

    export class ConfirmationContainerComponent implements AfterViewInit {
      // Internal component - not directly used
    }

    export abstract class ConfirmationMessage {
      abstract message: TemplateRef<any> | string | undefined;
    }

    export type ConfirmationOptions = {
      width: string;
      positiveLabel: string;
      negativeLabel: string;
      defaultMessage: string;
    }

    export const KBM_CONFIRMATION_OPTIONS: InjectionToken<ConfirmationOptions>

  Import paths:
    - Service and Directive: '@kebormed/x-core/components/confirmation'
    - Types: '@kebormed/x-core/components/confirmation' (type-only import)
    - Tokens: '@kebormed/x-core/components/confirmation'

Best Practices and Gotchas:
- Do: Use the service for programmatic confirmation dialogs
- Do: Use the directive for simple click-to-confirm scenarios
- Do: Provide custom configuration via KBM_CONFIRMATION_OPTIONS for consistent branding
- Do: Handle the observable subscription properly to avoid memory leaks
- Don't: Create multiple confirmation dialogs simultaneously (service manages single overlay)
- Don't: Forget to handle both true and false responses from the confirmation
- Don't: Use the ConfirmationContainerComponent directly - it's an internal implementation detail

Migration Notes:
- v1.0.0: Initial release with modern Angular features
- Uses standalone components and modern dependency injection patterns
- Leverages Angular CDK for overlay management and accessibility

Related Components / Patterns:
- Card Component: Used internally for dialog structure (@kebormed/x-core/components/card)
- Button Component: Used for action buttons (@kebormed/x-core/components/button)
- Angular CDK Overlay: Foundation for modal behavior
- Notification Component: Alternative for non-blocking user feedback
- Types: ContextWithImplicit<T> from @kebormed/x-core/types
- Utilities: kbmInjectElement from @kebormed/x-core/utils/dom

Configuration:
Default configuration can be overridden by providing KBM_CONFIRMATION_OPTIONS:

```ts
@NgModule({
  providers: [
    {
      provide: KBM_CONFIRMATION_OPTIONS,
      useValue: {
        width: '500px',
        positiveLabel: 'Confirm',
        negativeLabel: 'Cancel',
        defaultMessage: 'Please confirm your action'
      }
    }
  ]
})
export class AppModule {}
```

Changelog:
- v1.0.0: Initial release with service, directive, and container components

-----------------------------------------------------------

## File: ./projects/core/components/date-picker/date-picker.txt

DatePicker - Component Documentation
Status: stable
Since: v1.0.0

Short description: A flexible date picker component that allows users to select single dates or date ranges from a calendar interface with overlay positioning and form integration.

Purpose and Overview:
The DatePicker component provides an intuitive way for users to select dates or date ranges through a calendar-based UI. It consists of two main components (DatePickerComponent and RangePickerComponent) that extend a shared PickerBase class, along with supporting directives for form integration and toggle functionality. The component integrates seamlessly with Angular forms, supports configurable date constraints, and offers content projection for custom actions. It uses Angular CDK's overlay system for positioning and provides accessibility features including keyboard navigation and screen reader support.

Quick Start:
  Import:
    import {
      DatePickerComponent,
      RangePickerComponent,
      DatePickerDirective,
      DateRangePickerDirective,
      DatePickerToggleDirective
    } from '@kebormed/x-core/components/date-picker';

    @Component({
      imports: [
        DatePickerComponent,
        RangePickerComponent,
        DatePickerDirective,
        DateRangePickerDirective,
        DatePickerToggleDirective
      ]
    })
    export class MyComponent {}

  Minimal usage (HTML):
    <!-- Single date picker -->
    <kbm-date-picker #datePicker>
      <ng-template>
        <button (click)="datePicker.clear()">Clear</button>
      </ng-template>
    </kbm-date-picker>
    <input [kbmDatePicker]="datePicker">
    <button [kbmDatePickerToggle]="datePicker">📅</button>

    <!-- Date range picker -->
    <kbm-range-picker #rangePicker>
      <ng-template>
        <button (click)="rangePicker.clear()">Clear</button>
      </ng-template>
    </kbm-range-picker>
    <input [kbmDateRangePicker]="rangePicker">
    <button [kbmDatePickerToggle]="rangePicker">📅</button>

Inputs and Outputs:

DatePickerComponent / RangePickerComponent (extends PickerBase<T>):
- min: Date
  Description: Sets the minimum selectable date constraint

- max: Date
  Description: Sets the maximum selectable date constraint

- value: Date | DateRange | null = null
  Description: Current value of the picker (Date for DatePickerComponent, DateRange for RangePickerComponent)

- isRange: boolean = false
  Description: Indicates whether the picker should treat its value as a range (automatically set by component type)

- @Output() dateChoose: EventEmitter<Date | DateRange | null>
  Description: Emitted when a date is selected, payload type depends on component (Date or DateRange)

DatePickerDirective:
- kbmDatePicker: DatePickerComponent
  Description: References the date picker component to connect with input field

- min: Date
  Description: Sets the minimum selectable date (passed to picker component)

- max: Date
  Description: Sets the maximum selectable date (passed to picker component)

- displayFormat: string = inject(KBM_DATE_FORMAT) || DEFAULT_DATE_FORMAT
  Description: Format string for displaying dates in the input field

DateRangePickerDirective:
- kbmDateRangePicker: RangePickerComponent
  Description: References the range picker component to connect with input field

- min: Date
  Description: Sets the minimum selectable date (passed to picker component)

- max: Date
  Description: Sets the maximum selectable date (passed to picker component)

- displayFormat: string = inject(KBM_DATE_FORMAT) || DEFAULT_DATE_FORMAT
  Description: Format string for displaying date ranges in the input field

DatePickerToggleDirective:
- kbmDatePickerToggle: DatePickerComponent | RangePickerComponent
  Description: References the picker component to toggle when clicked

Slots and Content Projection:
Both <kbm-date-picker> and <kbm-range-picker> support content projection through <ng-template> to provide custom content below the calendar. The template receives the picker instance as $implicit context, allowing access to methods like clear() and setDate().

Example:
<kbm-date-picker #datePicker>
  <ng-template let-picker>
    <button (click)="picker.clear()">Clear</button>
    <button (click)="picker.setDate(today)">Today</button>
  </ng-template>
</kbm-date-picker>

Styling and Theming:
- CSS custom properties exposed:
  --kbm-date-picker-bg: Background color of the overlay panel (default: #fff)
  --kbm-date-picker-padding: Padding inside the overlay panel (default: 10px)
  --kbm-date-picker-border-radius: Border radius of the overlay panel (default: 10px)
  --kbm-date-picker-box-shadow: Box shadow of the overlay panel (default: 0 0 10px rgba(0, 0, 0, 0.1))

- The overlay panel has the CSS class 'kbm-date-picker' for additional custom styling
- The underlying calendar component styles are inherited
- Responsive behavior: The overlay uses flexible positioning to adapt to viewport constraints

Accessibility:
- Keyboard: Arrow keys for calendar navigation, Enter to select dates, Escape to close overlay, Tab for focus management
- ARIA: Required attributes are set on input fields (aria-required), calendar has proper ARIA roles and states
- Color contrast: Inherits from underlying calendar component, follows WCAG compliance
- Focus Management: Calendar automatically focuses the active cell when opened, focus returns to trigger element when closed
- Screen Readers: Proper labeling through host attributes ensures screen reader compatibility

Visual Examples:
Basic usage and variants:
  - Basic single date picker with input field and toggle button
  - Date range picker for selecting start and end dates
  - With min/max constraints to limit selectable date ranges
  - Custom action buttons through content projection
  - Disabled state through form control integration
  - Error state styling through form validation integration

Behaviors and Lifecycle:
The date picker components extend the abstract PickerBase class which implements OnDestroy for proper cleanup. The overlay behavior includes:
- Opens when toggle button is clicked via DatePickerToggleDirective
- Positioned using Angular CDK's flexible positioning relative to the toggle element
- Closes automatically when a date is selected, backdrop is clicked, Escape key is pressed, or component is destroyed
- Form integration through directives that extend CustomFieldControl, providing writeValue and other ControlValueAccessor methods
- Date formatting handled by DateAdapter using the displayFormat property
- Boundary constraints (min/max) are passed from directives to picker components via setBoundary() method

API Reference:
  Exports:
    export abstract class PickerBase<D> implements OnDestroy {
      min!: Date;
      max!: Date;
      value: D | null = null;
      isRange = false;
      @ContentChild(TemplateRef) bottomTemplate!: TemplateRef<ContextWithImplicit<PickerBase<D>>>;
      @Output() readonly dateChoose = new EventEmitter<D | null>();

      open(target: HTMLElement): void;
      close(): void;
      abstract clear(): void;
      abstract setDate(date: D): void;
      abstract handleDateChange(event: Date | DateRange | null): void;
    }

    export class DatePickerComponent extends PickerBase<Date> {
      selector: 'kbm-date-picker';
      exportAs: 'kbmDatePicker';
    }

    export class RangePickerComponent extends PickerBase<DateRange> {
      selector: 'kbm-range-picker';
      exportAs: 'kbmRangePicker';
    }

    export class DatePickerDirective extends CustomFieldControl<Date> implements OnInit {
      selector: 'input[kbmDatePicker]';
    }

    export class DateRangePickerDirective extends CustomFieldControl<DateRange> implements OnInit, OnDestroy {
      selector: 'input[kbmDateRangePicker]';
    }

    export class DatePickerToggleDirective {
      selector: '[kbmDatePickerToggle]';
    }

  Related Types (from @kebormed/x-core/types):
    export type DateRange = {
      start: Date | null;
      end: Date | null;
    };

    export interface ContextWithImplicit<T> {
      $implicit: T;
    }

  Related Tokens (from @kebormed/x-core/tokens):
    export const KBM_DATE_FORMAT = new InjectionToken<string>('KBM_DATE_FORMAT');

  Related Utilities (from @kebormed/x-core/utils):
    export class DateFormatPipe implements PipeTransform // For formatting dates in templates
    export function isDateRange(value: unknown): value is DateRange // For type checking

Best Practices and Gotchas:
- Do: Use the directives on input elements for proper form integration
- Do: Provide min/max constraints when appropriate for your use case
- Do: Use the toggle directive on a button or icon for better accessibility
- Do: Provide meaningful labels for screen readers
- Do: Use the KBM_DATE_FORMAT token to maintain consistent date formatting across the application
- Don't: Forget to include the picker component in your template when using directives
- Don't: Apply multiple date picker directives to the same input element
- Don't: Manually manage overlay lifecycle - let the component handle opening/closing
- Don't: Forget to handle the dateChoose event for form updates

Migration Notes:
N/A - This is the initial stable version of the component.

Related Components / Patterns:
- Calendar Component: The underlying calendar used by the date picker for date selection UI
- Form Controls: The date picker integrates with Angular reactive and template-driven forms
- DateFormatPipe: Utility pipe for consistent date formatting in templates (from @kebormed/x-core/utils/pipes)
- isDateRange function: Utility for type checking DateRange objects (from @kebormed/x-core/utils/miscellaneous)
- KBM_DATE_FORMAT token: Injection token for configuring date display format (from @kebormed/x-core/tokens)

Changelog:
- v1.0.0: Initial release with DatePickerComponent, RangePickerComponent, and supporting directives

-----------------------------------------------------------

## File: ./projects/core/components/form/form.txt

Form - Component Documentation
Status: stable
Since: v1.0.0

Short description: A structural directive for creating type-safe form action templates with access to form state and methods.

Purpose and Overview:
The Form module provides the FormActionDirective, a structural directive that enables developers to create reusable form action templates with type-safe access to form state and methods. It follows Angular's structural directive pattern using ContextWithImplicit to provide template context guards, ensuring type safety when accessing form properties like validation state, dirty/pristine status, and form actions like reset and submit. This directive is designed to work with any form implementation that conforms to the BaseFormAction interface.

Quick Start:
  Import:
    import { FormActionDirective } from '@kebormed/x-core/components/form';

    @Component({
      imports: [FormActionDirective]
    })
    export class MyFormComponent {}

  Minimal usage (HTML):
    <ng-template kbmFormAction let-form>
      <button [disabled]="!form.valid" (click)="form.submit()">Submit</button>
      <button (click)="form.reset($event)">Reset</button>
    </ng-template>

Inputs and Outputs:
The FormActionDirective does not have traditional @Input() or @Output() properties. Instead, it provides template context through the structural directive pattern:

Template Context Variables:
- $implicit: BaseFormAction - The form instance with access to all form state and methods
- form: BaseFormAction - Alias for $implicit, providing convenient access to form properties

Slots and Content Projection:
The directive works with ng-template elements using the kbmFormAction selector. The template receives a context object containing the form instance, allowing access to:
- Form state properties (valid, dirty, pristine, touched)
- Form action methods (submit, reset)
- Form identifier (id)

Styling and Theming:
The FormActionDirective is a structural directive and does not provide any styling or theming capabilities. Styling should be applied to the elements within the template content.

Accessibility:
- Keyboard: No specific keyboard handling - accessibility depends on the elements used within the template
- ARIA: No ARIA attributes are added by the directive - implement appropriate ARIA attributes on template elements
- Color contrast: Not applicable - the directive only provides template context

Visual Examples:
Basic usage and variants:
  - Basic form actions:
    <ng-template kbmFormAction let-form>
      <div class="form-actions">
        <button type="submit" [disabled]="!form.valid" (click)="form.submit()">
          Submit
        </button>
        <button type="button" (click)="form.reset($event)">
          Reset
        </button>
      </div>
    </ng-template>

  - Conditional actions based on form state:
    <ng-template kbmFormAction let-form>
      @if (form.dirty && !form.pristine) {
        <button (click)="form.reset($event)">Discard Changes</button>
      }
      @if (form.valid && form.touched) {
        <button (click)="form.submit()">Save</button>
      }
    </ng-template>

Behaviors and Lifecycle:
The FormActionDirective follows Angular's structural directive lifecycle:
- Constructor injection of TemplateRef for template access
- Static ngTemplateContextGuard for compile-time type safety
- No specific lifecycle hooks or performance optimizations

The directive uses TypeScript generics to maintain type safety across different form implementations while ensuring the template context conforms to the BaseFormAction interface.

API Reference:
  Exports:
    export class FormActionDirective<T> {
      constructor(public readonly template: TemplateRef<T>);
      static ngTemplateContextGuard<T>(
        _directive: FormActionDirective<T>,
        _context: ContextWithImplicit<BaseFormAction>
      ): _context is ContextWithImplicit<BaseFormAction>;
    }

    export interface BaseFormAction {
      id: string;
      valid: boolean;
      dirty: boolean;
      pristine: boolean;
      touched: boolean;
      reset(event: Event): void;
      submit(): void;
    }

  Import Path:
    import { FormActionDirective, BaseFormAction } from '@kebormed/x-core/components/form';

  Dependencies:
    - @angular/core (Directive, TemplateRef)
    - @kebormed/x-core/types (ContextWithImplicit)

Best Practices and Gotchas:
- Do: Use the let-form syntax to access form properties in templates
- Do: Implement the BaseFormAction interface in your form components when using this directive
- Do: Use the form.valid property to conditionally enable/disable submit buttons
- Do: Handle the Event parameter in the reset method for proper event handling
- Don't: Modify form state directly in templates - use the provided methods
- Don't: Forget to implement all required BaseFormAction interface properties and methods
- Don't: Use this directive without proper type checking - leverage the template context guard

Migration Notes:
- v1.0.0: Initial release - no migration needed

Related Components / Patterns:
- ContextWithImplicit<T> from @kebormed/x-core/types - Used for template context typing
- Other structural directives in the core library (table actions, confirmation templates)
- Angular Reactive Forms - Can be integrated with forms that implement BaseFormAction
- Template-driven forms - Compatible when wrapped with BaseFormAction interface

Changelog:
- v1.0.0: Initial release with FormActionDirective and BaseFormAction interface

-----------------------------------------------------------

## File: ./projects/core/components/icon/icon.txt

Icon - Component Documentation
Status: stable
Since: v1.0.0

Short description: A lightweight wrapper component for Material Symbols icons with customizable sizing and positioning support.

Purpose and Overview:
The Icon component provides a simple and consistent way to display Material Symbols icons throughout the application. It solves the problem of inconsistent icon styling and sizing by wrapping icon content in a properly styled container that ensures uniform appearance and alignment. The component uses content projection to accept icon names and applies the necessary CSS classes and styling for Material Symbols integration. It supports customizable sizing through CSS custom properties and includes special positioning attributes for use within other components like buttons.

Quick Start:
  Import:
    import { IconComponent } from '@kebormed/x-core/components/icon';

    @Component({
      imports: [IconComponent]
    })
    export class DemoComponent {}

  Minimal usage (HTML):
    <kbm-icon>home</kbm-icon>

Inputs and Outputs:
The Icon component has no @Input() or @Output() properties. It uses HTML attributes for configuration:

- end: HTML attribute (not an Angular input)
  Description: When present, indicates that the icon should be positioned at the end of its container. Used primarily with button components for icon placement control.

Slots and Content Projection:
The component uses a single content projection slot:
- Default slot: Accepts the Material Symbols icon name as text content

Examples:
  <kbm-icon>home</kbm-icon>
  <kbm-icon>delete</kbm-icon>
  <kbm-icon>calendar_month</kbm-icon>
  <kbm-icon end>arrow_forward</kbm-icon>

Styling and Theming:
- CSS custom properties exposed:
  - --kbm-icon-size: Controls the width, height, and font-size of the icon. Default is 24px.

- CSS classes applied:
  - .kbm-icon: Applied via host binding for component styling
  - .material-symbols-outlined: Applied via host binding for Material Symbols integration

- Composition tips:
  - Use within button components for enhanced visual communication
  - Customize size using the --kbm-icon-size CSS custom property
  - Use the 'end' attribute when placing icons at the end of button components

- Responsive behavior:
  - Icons maintain their aspect ratio and scale based on the --kbm-icon-size property
  - Default size is 24px, suitable for most UI contexts

Accessibility:
- Keyboard: Icons are presentational by default and do not receive keyboard focus
- ARIA: Icons are decorative elements. When used for functional purposes, ensure appropriate ARIA attributes are added to the parent element or provide alternative text
- Color contrast: Ensure sufficient contrast between icon color and background to meet WCAG compliance requirements

Visual Examples:
Basic usage and variants:
  - Basic:
    <kbm-icon>home</kbm-icon>

  - Custom Size:
    <kbm-icon style="--kbm-icon-size: 32px;">home</kbm-icon>

  - Within Button (Start Position):
    <button kbm-button>
      <kbm-icon>add</kbm-icon>
      Add Item
    </button>

  - Within Button (End Position):
    <button kbm-button>
      Continue
      <kbm-icon end>arrow_forward</kbm-icon>
    </button>

Behaviors and Lifecycle:
The Icon component is a simple wrapper with minimal behavior:
- Uses OnPush change detection strategy for optimal performance
- ViewEncapsulation.None allows global styling of Material Symbols
- No complex lifecycle hooks or internal services
- Content is projected directly without transformation

API Reference:
  Exports:
    export class IconComponent {
      // No public properties or methods
      // Styling applied through host bindings:
      // '[class.kbm-icon]': 'true'
      // '[class.material-symbols-outlined]': 'true'
    }

Best Practices and Gotchas:
- Do: Use meaningful icon names that clearly represent their purpose
- Do: Maintain consistent icon usage throughout your application
- Do: Use the 'end' attribute when placing icons at the end of buttons
- Do: Customize icon size using the --kbm-icon-size CSS custom property
- Do: Ensure icons have sufficient color contrast for accessibility
- Don't: Use too many icons in a single view as it can create visual noise
- Don't: Use icons without labels for critical actions, as their meaning may not be clear to all users
- Don't: Forget to include Material Symbols font in your application

Migration Notes:
Not applicable for the initial version.

Related Components / Patterns:
- Button Component: Icons are commonly used within buttons to enhance visual communication and provide visual cues
- Material Symbols: This component is designed specifically to work with the Material Symbols icon set from Google Fonts
- Form Controls: Icons are often used in form inputs and controls for visual enhancement

Changelog:
- v1.0.0: Initial release

-----------------------------------------------------------

## File: ./projects/core/components/input/input.txt

Input - Component Documentation
Status: stable
Since: v1.0.0

Short description: A comprehensive input system providing form controls, input groups, error handling, and content projection for building consistent form interfaces.

Purpose and Overview:
The Input component system solves the problem of form input management by providing a unified API for different types of inputs with consistent styling, behavior, and validation. It integrates seamlessly with Angular's reactive forms system and provides features like error state handling, required field marking, accessibility support, and flexible content projection. The system consists of three main components: InputDirective for form control integration, InputGroupComponent for layout and orchestration, and InputErrorComponent for validation feedback. Key design decisions include using the FieldControl abstraction for consistency, implementing OnPush change detection for performance, and providing extensive customization through CSS custom properties.

Quick Start:
  Import:
    import {
      InputDirective,
      InputGroupComponent,
      InputErrorComponent,
      PrefixDirective,
      SuffixDirective,
      LabelDirective
    } from '@kebormed/x-core/components/input';

    @Component({
      imports: [
        InputDirective,
        InputGroupComponent,
        PrefixDirective,
        SuffixDirective,
        LabelDirective
      ]
    })
    export class DemoComponent {}

  Minimal usage (HTML):
    <kbm-input-group>
      <kbm-label>Username</kbm-label>
      <input kbmInput placeholder="Enter username">
    </kbm-input-group>

Inputs and Outputs:

InputDirective:
- @Input() id: string = Auto-generated
  Description: Sets the ID of the input element. Auto-generates unique IDs with 'input-' prefix if not provided.

- @Input() name: string
  Description: Sets the name attribute of the input element for form submission and accessibility.

- @Input() placeholder: string
  Description: Sets the placeholder text displayed when the input is empty.

- @Input() disabled: boolean = false
  Description: Disables the input element. Supports boolean coercion and syncs with Angular form control state.

- @Input() required: boolean = false
  Description: Marks the input as required. Auto-detects from Angular validators if not explicitly set.

- @Input() value: any
  Description: Sets the value of the input. Triggers state changes when modified.

- @Input() errorStateMatcher: ErrorStateMatcher | null = null
  Description: Custom error state matcher for determining when to show error states. Falls back to default matcher if not provided.

InputGroupComponent:
- @Input() withoutError: boolean = false
  Description: When true, hides error messages from being displayed below the input.

- @Input() requiredMarker: boolean = true
  Description: Shows or hides the required field marker (*) next to the label when the input is required.

InputErrorComponent:
- No direct inputs (configured through injection tokens)
  Description: Automatically displays validation error messages based on form control state and error message configuration.

Slots and Content Projection:
The input system supports extensive content projection:

InputGroupComponent:
- <kbm-label>: Projects content into the label area above the input
- [kbmPrefix]: Projects content before the input field (e.g., currency symbols, icons)
- [kbmSuffix]: Projects content after the input field (e.g., units, action buttons)
- Input element with kbmInput directive: The main form control element
- .kbm-error: Additional error content projection slot

Supported input elements:
- <input kbmInput>: Text, email, password, number, and other input types
- <textarea kbmInput>: Multi-line text input
- <select kbmInput>: Dropdown selection

Styling and Theming:
The input components are highly customizable through CSS custom properties:

Input and Input Group:
- --kbm-label-font-size: 1rem - Font size of the label text
- --kbm-label-font-weight: 400 - Font weight of the label text
- --kbm-label-color: inherit - Text color of the label
- --kbm-label-disabled-color: #ccc - Label color when input is disabled
- --kbm-input-border-color: #ccc - Border color of the input field
- --kbm-input-border-size: 1px - Border thickness of the input field
- --kbm-input-height: 30px - Height of the input field
- --kbm-input-radius: 0 - Border radius of the input field
- --kbm-input-background: transparent - Background color of the input
- --kbm-input-disabled-background: #ccc - Background when disabled
- --kbm-input-font-size: 12px - Font size of input text
- --kbm-input-color: inherit - Text color of input content
- --kbm-input-focus-border-color: #3fa9f5 - Border color when focused
- --kbm-input-disabled-border-color: #ccc - Border color when disabled
- --kbm-input-error-color: - Text color for error messages
- --kbm-input-subscript-font-size: 0.9rem - Font size for error text

Composition tips:
- Wrap in container elements for additional styling control
- Use CSS Grid or Flexbox for complex form layouts
- Combine with card components for elevated form sections

Accessibility:
- Keyboard: Input elements are natively keyboard accessible with proper tab order and focus management
- ARIA: Automatic ARIA attributes including aria-required, aria-disabled, and proper label associations
- Color contrast: Customizable through theming variables to meet WCAG AA requirements
- Screen readers: Proper semantic markup and error announcements

Visual Examples:
Basic usage and variants:
  - Basic Input:
    Simple text input with label and automatic error handling
  - Input with Prefix/Suffix:
    Currency input with prefix symbol and suffix unit display
  - Textarea:
    Multi-line text input for longer content
  - Select Dropdown:
    Native select element with consistent styling
  - Disabled State:
    Input with disabled styling and reduced opacity
  - Error State:
    Input with error border color and error message display

Behaviors and Lifecycle:
The input system implements several lifecycle optimizations:
- OnPush change detection strategy for improved performance
- DoCheck implementation in InputDirective to sync with Angular form control state
- AfterContentInit in InputGroupComponent to establish subscriptions to state changes
- Automatic cleanup of subscriptions using takeUntilDestroyed
- Error state evaluation using configurable ErrorStateMatcher service
- State forwarding from form controls to CSS classes for styling
- Focus management and container click handling for improved UX

API Reference:
  Exports:
    export class InputDirective implements FieldControl<any>, OnDestroy, DoCheck, OnChanges {
      @Input() name: string;
      @Input() placeholder: string;
      @Input() errorStateMatcher: KbmNullable<ErrorStateMatcher>;
      @Input() id: string;
      @Input() disabled: boolean;
      @Input() required: boolean;
      @Input() value: unknown;
      readonly stateChanges: Subject<void>;
      readonly ngControl: NgControl | null;
      focus(options?: FocusOptions): void;
      onContainerClick(): void;
    }

    export class InputGroupComponent implements AfterContentInit {
      @Input() withoutError: boolean;
      @Input() requiredMarker: boolean;
      setErrorDisplay(value: boolean): void;
      setRequiredMarker(value: boolean): void;
    }

    export class InputErrorComponent implements DoCheck, AfterViewInit {
      readonly hasError: boolean;
      readonly errors: string;
    }

    export class ErrorStateMatcher {
      isErrorState(control: NgControl | AbstractControlDirective | null, form: FormGroupDirective | NgForm | null): boolean;
    }

    export class PrefixDirective {}
    export class SuffixDirective {}
    export class LabelDirective {}

    export const KBM_INPUT_VALUE_ACCESSOR: InjectionToken<any>;
    export const KBM_FORM_ERROR_MESSAGES: InjectionToken<ValidationErrorMap>;
    export const KBM_INPUT_GROUP: InjectionToken<InputGroupComponent>;

  Types (from @kebormed/x-core/types):
    export type KbmNullable<T> = T | null;
    export type ValidationErrorMap = Record<string, string | ((error: any) => string)>;

Best Practices and Gotchas:
- Do: Use kbm-input-group to wrap input elements for consistent styling and behavior
- Do: Use the kbmInput directive on native input elements to integrate with the form system
- Do: Provide meaningful labels for all input elements using kbm-label
- Do: Configure error messages through the KBM_FORM_ERROR_MESSAGES injection token
- Do: Use the ErrorStateMatcher for consistent error state handling across the application
- Don't: Apply multiple input directives to the same element
- Don't: Forget to handle form validation and provide appropriate error messages
- Don't: Nest input groups within each other as this can cause styling conflicts
- Don't: Override the internal state management - use the provided APIs instead

Migration Notes:
Not applicable for initial release.

Related Components / Patterns:
- Form Component: Often used to group multiple input components in structured layouts
- Button Component: Used alongside inputs for form submission and actions
- Card Component: Provides elevated containers for form sections
- Validation utilities from @kebormed/x-core/utils/validation
- ErrorStateMatcher from @kebormed/x-core/abstraction/error-state-matcher
- FieldControl abstraction from @kebormed/x-core/abstraction/field

Changelog:
- v1.0.0: Initial release with InputDirective, InputGroupComponent, and InputErrorComponent

-----------------------------------------------------------

## File: ./projects/core/components/notification/notification.txt

Notification - Component Documentation
Status: stable
Since: v1.0.0

Short description: A service-based notification system for displaying temporary, non-intrusive messages to users with customizable positioning and theming.

Purpose and Overview:
The Notification component provides a comprehensive solution for displaying temporary messages to users in Angular applications. It solves the problem of providing user feedback for actions, errors, warnings, and informational messages without blocking the user interface. The component uses Angular CDK Overlay for positioning and supports four notification types (info, success, warning, error) with automatic timeout and manual dismissal. Key design decisions include service-based architecture for easy injection, dynamic component creation for performance, and extensive theming support through CSS custom properties.

Quick Start:
  Import:
    import { KbmNotification } from '@kebormed/x-core/components/notification';

    @Component({
      // ...
    })
    export class MyComponent {
      private notification = inject(KbmNotification);
    }

  Minimal usage (TypeScript):
    // Basic notification
    this.notification.info('Operation completed successfully');

    // Different types
    this.notification.success('Data saved successfully');
    this.notification.warning('Please check your input');
    this.notification.error('An error occurred');

    // Generic notify method
    this.notification.notify('Custom message', 'info');

Inputs and Outputs:
Service Methods:
- notify(message: string, type: NotificationType = 'info'): void
  Description: Displays a notification with the specified message and type. Type can be 'info', 'success', 'warning', or 'error'.

- info(message: string): void
  Description: Displays an informational notification with blue styling.

- success(message: string): void
  Description: Displays a success notification with green styling.

- warning(message: string): void
  Description: Displays a warning notification with yellow/orange styling.

- error(message: string): void
  Description: Displays an error notification with red styling.

Configuration Options (via KBM_NOTIFICATION_OPTIONS token):
- timeout: number = 5000
  Description: Duration in milliseconds before the notification automatically disappears.

- verticalPosition: 'top' | 'bottom' = 'top'
  Description: Vertical positioning of the notification container.

- horizontalPosition: 'left' | 'right' | 'center' = 'right'
  Description: Horizontal positioning of the notification container.

Slots and Content Projection:
Not applicable - the notification component is service-driven and doesn't support content projection. Messages are passed as string parameters to the service methods.

Styling and Theming:
The notification component supports extensive customization through CSS custom properties:

Core Variables:
- --notification-bg: Default background color (default: #fff)
- --notification-color: Default text color (default: #333)
- --notification-container-padding: Inner padding (default: 5px)
- --notification-font-size: Text size (default: 1rem)
- --notification-container-border-radius: Corner radius (default: 4px)

Type-specific Variables:
- --notification-success-background: Background for success notifications
- --notification-success-color: Text color for success notifications
- --notification-error-background: Background for error notifications
- --notification-error-color: Text color for error notifications
- --notification-warning-background: Background for warning notifications
- --notification-warning-color: Text color for warning notifications
- --notification-info-background: Background for info notifications
- --notification-info-color: Text color for info notifications

Responsive behavior: Notifications have a fixed width of 500px and are positioned using Angular CDK Overlay for consistent placement across different screen sizes.

Accessibility:
- Keyboard: Close button is focusable and can be activated with Enter or Space
- ARIA: Notifications are announced to screen readers when they appear
- Color contrast: Theming variables should maintain WCAG AA compliance
- Auto-dismiss: 5-second timeout provides sufficient reading time while not persisting indefinitely

Visual Examples:
Basic usage and variants:
  - Info: Blue-themed notification for general information
  - Success: Green-themed notification for successful operations
  - Warning: Yellow/orange-themed notification for warnings
  - Error: Red-themed notification for errors
  - All notifications include a close button (×) for manual dismissal
  - Smooth scale and opacity animations on show/hide

Behaviors and Lifecycle:
- Notifications appear with a scale and fade-in animation
- Auto-dismiss after configured timeout (default 5000ms)
- Manual dismissal via close button triggers fade-out animation
- Multiple notifications stack vertically based on vertical position setting
- New notifications appear at top (for top positioning) or bottom (for bottom positioning)
- Component cleanup automatically removes event listeners and clears timeouts
- Uses Angular's OnPush change detection strategy for performance

API Reference:
  Exports:
    export class KbmNotification {
      notify(message: string, type: NotificationType = 'info'): void
      info(message: string): void
      success(message: string): void
      warning(message: string): void
      error(message: string): void
    }

    export type NotificationType = 'info' | 'success' | 'warning' | 'error'

    export interface NotificationOptions {
      timeout: number;
      verticalPosition: 'top' | 'bottom';
      horizontalPosition: 'left' | 'right' | 'center';
    }

    export const KBM_NOTIFICATION_OPTIONS: InjectionToken<NotificationOptions>
    export const KBM_DEFAULT_NOTIFICATION_OPTIONS: NotificationOptions

Best Practices and Gotchas:
- Do: Use appropriate notification types (success for confirmations, error for failures, etc.)
- Do: Keep messages concise and actionable
- Do: Configure positioning based on your application's layout
- Do: Customize theming variables to match your design system
- Don't: Display notifications for every minor action - reserve for important feedback
- Don't: Use extremely long messages that might not fit well in the notification
- Don't: Rely solely on color to convey meaning - include clear text descriptions
- Gotcha: Notifications use Angular CDK Overlay, ensure CDK styles are included in your application

Migration Notes:
- v1.0.0: Initial release - no migration needed

Related Components / Patterns:
- Confirmation Component: For blocking user interactions requiring explicit confirmation
- Toast/Snackbar patterns: Similar temporary messaging solutions
- Alert Component: For persistent, prominent messaging
- Angular CDK Overlay: Underlying positioning system used by this component

Changelog:
- v1.0.0: Initial release with service-based architecture, four notification types, configurable positioning, and comprehensive theming support

-----------------------------------------------------------

## File: ./projects/core/components/pagination/pagination.txt

Paginator - Component Documentation
Status: stable
Since: v1.0.0

Short description: A modern Angular pagination component that enables navigation through paginated data with customizable controls and signal-based reactivity.

Purpose and Overview:
The Paginator component solves the problem of navigating through large datasets by providing an intuitive user interface for page-based navigation. It's built using modern Angular patterns including standalone components, signals for reactive state management, and the new control flow syntax. The component automatically calculates pagination state, validates user input, and provides comprehensive page change events. Key design decisions include using signals for optimal change detection performance, input validation to prevent invalid page numbers, and a clean, accessible interface with optional first/last page buttons.

Quick Start:
  Import:
    import { PaginatorComponent } from '@kebormed/x-core/components/pagination';
    @Component({
      imports: [PaginatorComponent]
    })
    export class DemoComponent {}

  Minimal usage (HTML):
    <kbm-paginator
      [totalItems]="100"
      [pageSize]="10"
      [(pageIndex)]="currentPage"
      (page)="onPageChange($event)">
    </kbm-paginator>

Inputs and Outputs:
- totalItems: InputSignal<number> (required)
  Description: Sets the total number of items to paginate. Used to calculate the total number of pages.

- pageSize: InputSignal<number> = 10
  Description: Sets the number of items per page. Defaults to 10 items per page.

- showFirstLastButtons: InputSignal<boolean> = false
  Description: Shows or hides the first/last page navigation buttons. When true, displays additional buttons for jumping to the first and last pages.

- pageIndex: ModelSignal<number> = 1
  Description: Two-way binding for the current page index. Automatically clamped to valid range (1 to numberOfPages).

- page: OutputEmitterRef<PageEvent>
  Description: Emitted when the page changes. Provides comprehensive pagination state including previous page, current page, page size, and total items.

Slots and Content Projection:
The paginator component does not support content projection or slots. It provides a complete, self-contained pagination interface.

Styling and Theming:
- CSS custom properties exposed:
  * --kbm-paginator-width: Controls the size of buttons and elements (default: 24px)
  * --kbm-paginator-text-color: Controls text color (default: #000)
  * --kbm-paginator-icon-color: Controls icon color (default: #000)
- Composition tips: The component uses flexbox layout and adapts to its container width. Can be easily integrated into table footers or content areas.
- Responsive behavior: The component maintains its layout across different screen sizes, with buttons and input field scaling appropriately.

Accessibility:
- Keyboard: All navigation buttons are focusable and can be activated with Enter/Space keys. The page input field supports keyboard navigation, Enter key submission, and proper focus management.
- ARIA: Navigation buttons have appropriate disabled states when navigation is not possible (e.g., previous button disabled on first page). SVG icons are marked as non-focusable for screen readers.
- Color contrast: Default colors provide sufficient contrast for WCAG compliance, with customization available via CSS custom properties.

Visual Examples:
Basic usage and variants:
  - Basic
    Displays current page indicator, previous/next navigation buttons, and a direct page input field.
  - Variants / States:
    * With First/Last Buttons: When showFirstLastButtons is true, additional navigation buttons appear for jumping to first and last pages
    * Disabled States: Navigation buttons are automatically disabled when navigation is not possible (previous on first page, next on last page)
    * Input Validation: Page input field validates and sanitizes user input, preventing invalid page numbers

Behaviors and Lifecycle:
The component implements OnChanges to handle input changes gracefully. When totalItems or pageSize change, it automatically recalculates the number of pages and adjusts the current page if necessary. The component uses computed signals for derived state (numberOfPages, hasPreviousPage, hasNextPage) ensuring optimal performance with OnPush change detection. Input validation prevents non-numeric characters and automatically clamps page numbers to valid ranges. The component uses utility functions from @kebormed/x-core/utils/miscellaneous (kbmClamp for value clamping and kbmIsNumber for type checking) to ensure robust input handling.

API Reference:
  Exports:
    export class PaginatorComponent implements OnChanges {
      // Input signals
      totalItems: InputSignal<number>;
      pageSize: InputSignal<number>;
      showFirstLastButtons: InputSignal<boolean>;

      // Model signal (two-way binding)
      pageIndex: ModelSignal<number>;

      // Output
      page: OutputEmitterRef<PageEvent>;

      // Computed signals
      numberOfPages: Signal<number>;
      hasPreviousPage: Signal<boolean>;
      hasNextPage: Signal<boolean>;

      // Navigation methods
      nextPage(): void;
      previousPage(): void;
      firstPage(): void;
      lastPage(): void;
      goToPage(event: Event): void;
      handleKeyDown(event: KeyboardEvent): void;
      handleFocusOut(event: FocusEvent): void;
    }

    export type PageEvent = {
      previousPage: number;
      page: number;
      pageSize: number;
      total: number;
    };

Best Practices and Gotchas:
- Do: Always provide the totalItems input as it's required for proper pagination calculation
- Do: Handle the page output event to update your data source accordingly
- Do: Use showFirstLastButtons for large datasets to improve navigation efficiency
- Do: Leverage the two-way binding with pageIndex for seamless state management
- Don't: Manually set pageIndex to values outside the valid range (component automatically clamps values)
- Don't: Forget to update totalItems when your data source changes, as this affects page calculations
- Don't: Rely on the component for data fetching - it only manages pagination state

Migration Notes:
This is the initial release of the component. Future versions will maintain backward compatibility for the public API while potentially adding new features like page size selection or custom button templates.

Related Components / Patterns:
- Table component from @kebormed/x-core/components/table - Often used together for displaying paginated tabular data
- List components - Can be paginated using this component for large datasets
- Data services - Should implement pagination logic that works with the PageEvent interface
- Core types from @kebormed/x-core/types - The Pagination type can be used alongside this component for API responses

Changelog:
- v1.0.0: Initial release with signal-based architecture, standalone component support, and modern Angular patterns

-----------------------------------------------------------

## File: ./projects/core/components/sort/sort.txt

Sort - Component Documentation
Status: stable
Since: v1.0.0

Short description: A directive and component pair that enables sortable columns in tables or lists with visual indicators and state management.

Purpose and Overview:
The Sort component provides a comprehensive solution for adding sorting functionality to table headers, list items, or any clickable elements. It consists of two main parts: the `SortDirective` which manages the overall sorting state and coordinates between multiple sortable items, and the `SortableComponent` which represents individual sortable elements with visual feedback. The component handles three-state sorting (ascending, descending, unsorted) and provides customizable visual indicators including arrows and sortable marks.

Quick Start:
  Import:
    import { SortDirective, SortableComponent } from '@kebormed/x-core/components/sort';
    @Component({
      imports: [SortDirective, SortableComponent]
    })
    export class DemoComponent {}

  Minimal usage (HTML):
    <div kbmSort (kbmSort)="onSort($event)">
      <span kbm-sortable="name">Name</span>
      <span kbm-sortable="age">Age</span>
      <span kbm-sortable="email">Email</span>
    </div>

Inputs and Outputs:

SortDirective:
- @Input() active: KbmOptional<string>
  Description: The currently active sort field identifier. Can be undefined when no sorting is applied.

- @Input() direction: SortDirection
  Description: The current sort direction. Can be 'asc', 'desc', or undefined for unsorted state.

- @Input() showArrowOnUnsorted: boolean = false
  Description: Whether to show a semi-transparent arrow indicator on unsorted items. Accepts boolean values and uses coerceBooleanProperty transform.

- @Output() kbmSort: EventEmitter<SortEvt>
  Description: Emits when sorting state changes. Payload contains {attr: string | undefined, dir: SortDirection} where attr is the field identifier and dir is the sort direction.

SortableComponent:
- @Input('kbm-sortable') id: string
  Description: The unique identifier for this sortable item. Required for proper sorting functionality.

- @Input() withSortMark: boolean = true
  Description: Whether to display the sortable indicator (hamburger menu icon). Uses coerceBooleanProperty transform.

Slots and Content Projection:
The SortableComponent supports content projection through <ng-content>, allowing any content to be placed inside the sortable element. The component automatically adds visual indicators (sort arrows and sortable marks) around the projected content.

Styling and Theming:
- CSS custom properties:
  - --kbm-sortable-indicator-display: Controls the display property of the sortable indicator (default: inline)

- Visual indicators:
  - Ascending sort: ↑ (Unicode \2191)
  - Descending sort: ↓ (Unicode \2193)
  - Unsorted with showArrowOnUnsorted: ↑ with 50% opacity
  - Sortable indicator: Hamburger menu SVG icon (12px × 12px)

- Host element styling:
  - Sortable elements receive cursor: pointer
  - Automatic .sortable CSS class binding

Accessibility:
- Keyboard: Click events are handled for sorting activation. Consider adding keyboard navigation support for better accessibility.
- ARIA: The sortable indicator includes a "Sortable" title attribute for screen readers.
- Color contrast: Visual indicators use Unicode arrows which inherit text color, ensuring proper contrast.

Visual Examples:
Basic usage and variants:
  - Basic sortable table headers with sort indicators
  - List items with optional sortable marks
  - Custom content with projected elements

Behaviors and Lifecycle:
The component implements a three-state sorting cycle:
1. Unsorted (undefined) → Ascending ('asc') on first click
2. Ascending ('asc') → Descending ('desc') on second click
3. Descending ('desc') → Unsorted (undefined) on third click

The SortDirective manages state across all registered sortable items, ensuring only one item can be actively sorted at a time. When a new item is sorted, the previous item automatically returns to unsorted state.

Performance optimizations:
- Uses OnPush change detection strategy
- Subscription-based state updates to minimize unnecessary re-renders
- Efficient Map-based storage for registered sortable items

API Reference:
  Exports:
    export class SortDirective implements OnDestroy
    export class SortableComponent extends Sortable implements OnInit, OnDestroy
    export abstract class Sortable { abstract id: string; }
    export type SortDirection = 'asc' | 'desc' | undefined;
    export type SortEvt = {attr: string | undefined; dir: SortDirection};

  Types from @kebormed/x-core/types:
    - KbmOptional<T>: Used for optional string values

  Utilities from @kebormed/x-core:
    - Uses coerceBooleanProperty from @angular/cdk/coercion for input transforms

Best Practices and Gotchas:
- Do: Always use SortableComponent inside a SortDirective container
- Do: Provide unique id values for each sortable item
- Do: Handle the kbmSort output event to update your data source
- Do: Use the withSortMark input to control visual indicators based on your design needs
- Don't: Use SortableComponent without a parent SortDirective (will throw an error)
- Don't: Forget to implement sorting logic in your component when handling kbmSort events
- Don't: Use duplicate id values for sortable items within the same sort context

Migration Notes:
- v1.0.0: Initial release with standalone component architecture
- Components are standalone by default, no NgModule imports required
- Uses modern Angular features like output() function and signal-based reactivity

Related Components / Patterns:
- Table Component: Often used together for sortable table headers
- List Components: Can be enhanced with sorting functionality
- Pagination Component: Commonly combined with sorting for data tables
- Material Design: Follows similar patterns to Angular Material's MatSort

Changelog:
- v1.0.0: Initial release with SortDirective and SortableComponent

-----------------------------------------------------------

## File: ./projects/core/components/tab/tab.txt

Tab - Component Documentation
Status: stable
Since: v1.0.0

Short description: A modern Angular tab system with keyboard navigation, accessibility support, and flexible content projection using signals and standalone components.

Purpose and Overview:
The Tab component system provides a complete tabbed interface solution consisting of a TabGroupComponent that manages multiple TabComponent instances. It solves the problem of organizing content into switchable panels while maintaining full accessibility compliance and keyboard navigation. The system uses modern Angular features including signals for reactive state management, the new input() function, and standalone components. Key design decisions include using CSS custom properties for theming flexibility and supporting both string labels and template-based labels for maximum customization.

Quick Start:
  Import:
    import { TabGroupComponent, TabComponent, TabContentDirective, TabLabelDirective } from '@kebormed/x-core/components/tab';

    @Component({
      imports: [TabGroupComponent, TabComponent, TabContentDirective, TabLabelDirective]
    })
    export class DemoComponent {}

  Minimal usage (HTML):
    <kbm-tab-group (tabChange)="onTabChange($event)">
      <kbm-tab label="Tab 1">
        <p>Content for tab 1</p>
      </kbm-tab>
      <kbm-tab label="Tab 2">
        <p>Content for tab 2</p>
      </kbm-tab>
    </kbm-tab-group>

Inputs and Outputs:

TabGroupComponent:
- @Output() tabChange: EventEmitter<number>
  Description: Emitted when the active tab changes, providing the index of the newly selected tab

TabComponent:
- label = input<TemplateRef<ContextWithImplicit<TabContext>> | string>('')
  Description: The tab label, can be a string or a template reference for custom label rendering

- @Input('aria-label') ariaLabel: string | null = null
  Description: ARIA label for accessibility, overrides the default label

- @Input('aria-labelledby') ariaLabelledby: string | null = null
  Description: ARIA labelledby attribute for accessibility

- @Input({transform: booleanAttribute}) disabled: boolean = false
  Description: Whether the tab is disabled and cannot be selected

- @Input({transform: coerceBooleanProperty}) active: boolean = false
  Description: Whether the tab is initially active (only one tab should be active)

TabLabelDirective:
- kbmTabLabel = input<TemplateRef<unknown>>()
  Description: Template reference for custom tab label content

Slots and Content Projection:
- Default slot: Content projected into TabComponent becomes the tab panel content
- [kbmTabContent]: Directive to mark specific content as tab content template
- [kbmTabLabel]: Directive for custom tab label templates with access to TabContext
- Template context for labels includes: { index: number, active: boolean, disabled: boolean, focusIndex: number }

Styling and Theming:
- CSS custom properties for complete theming control:
  - --kbm-tab-header-border-color: Border color for tab header (default: #ccc)
  - --kbm-tab-header-border-width: Border width for tab header (default: 1px)
  - --kbm-tab-header-padding: Padding for tab labels (default: 1rem)
  - --kbm-tab-label-color: Text color for inactive tabs (default: #000)
  - --kbm-tab-label-background-color: Background color for inactive tabs (default: #FFF)
  - --kbm-tab-label-font-size: Font size for tab labels (default: 1rem)
  - --kbm-tab-label-radius: Border radius for tab labels (default: 0)
  - --kbm-tab-label-width: Width for tab labels (default: auto)
  - --kbm-tab-label-active-color: Text color for active tab (default: #000)
  - --kbm-tab-label-active-background-color: Background color for active tab (default: #FFF)
  - --kbm-tab-label-disabled-background-color: Background color for disabled tabs (default: #FFF)
  - --kbm-tab-label-disabled-color: Text color for disabled tabs (default: #FFF)
  - --kbm-tab-label-focused-background-color: Background color for focused tabs (default: #FFF)
  - --kbm-tab-label-focused-color: Text color for focused tabs (default: #000)
- Responsive behavior: Tabs use flexbox layout and adapt to container width
- Composition: Can be wrapped in other components for additional styling or layout

Accessibility:
- Keyboard: Full keyboard navigation support
  - Arrow keys (Left/Right/Up/Down) navigate between tabs
  - Enter or Space activates the focused tab
  - Tab key moves focus into and out of the tab group
  - Focus management with proper tabindex handling
- ARIA: Complete ARIA implementation
  - role="tablist" on the tab header container
  - role="tab" on individual tab buttons
  - aria-selected indicates the active tab
  - aria-controls links tabs to their content panels
  - Support for custom aria-label and aria-labelledby
- Color contrast: Uses CSS custom properties allowing full control over colors for WCAG compliance

Visual Examples:
Basic usage and variants:
  - Basic string labels:
    <kbm-tab-group>
      <kbm-tab label="Home">Home content</kbm-tab>
      <kbm-tab label="About">About content</kbm-tab>
    </kbm-tab-group>

  - Template labels:
    <kbm-tab-group>
      <kbm-tab [label]="customLabelTemplate">
        <ng-template #customLabelTemplate let-context>
          <i class="icon"></i> {{ context.index + 1 }}
        </ng-template>
        Content with custom label
      </kbm-tab>
    </kbm-tab-group>

  - States:
    * Active: Automatically managed by TabGroupComponent
    * Disabled: <kbm-tab label="Disabled" [disabled]="true">
    * Focused: Handled automatically during keyboard navigation

Behaviors and Lifecycle:
- OnInit: TabGroupComponent automatically selects the first active tab or defaults to the first tab
- Tab selection: Managed through signals with reactive updates
- Focus management: Uses CDK focus monitoring for proper focus handling
- Performance: Uses OnPush change detection strategy and signals for optimal performance
- Template caching: Tab content templates are cached and reused efficiently

API Reference:
  Exports:
    export class TabComponent {
      label = input<TemplateRef<ContextWithImplicit<TabContext>> | string>('');
      ariaLabel: string | null;
      ariaLabelledby: string | null;
      disabled: boolean;
      active: boolean;
      template: Signal<TemplateRef<unknown> | null>;
      tabLabel: Signal<TemplateRef<ContextWithImplicit<TabContext>> | string>;
      isLabelTemplate: Signal<boolean>;
      labelTemplate: Signal<TemplateRef<ContextWithImplicit<TabContext>>>;
    }

    export class TabGroupComponent implements OnInit {
      readonly tabs: Signal<readonly TabComponent[]>;
      activeTab: WritableSignal<TabComponent | undefined>;
      tabChange: OutputEmitterRef<number>;
      groupId: string;
      handleClick(index: number): void;
      handleKeyDown(event: KeyboardEvent): void;
    }

    export class TabContentDirective {}

    export class TabLabelDirective {
      kbmTabLabel = input<TemplateRef<unknown>>();
    }

    export interface TabContext {
      index: number;
      active: boolean;
      disabled: boolean;
      focusIndex: number;
    }

Best Practices and Gotchas:
- Do: Use signals and the new input() function for reactive state management
- Do: Provide meaningful labels for accessibility
- Do: Use CSS custom properties for consistent theming
- Do: Handle the tabChange event to respond to tab selection
- Do: Use template labels when you need dynamic or complex label content
- Don't: Set multiple tabs as active initially (only the first one will be respected)
- Don't: Forget to import all necessary components and directives
- Don't: Override focus styles without ensuring accessibility compliance
- Don't: Use complex logic in templates; prefer computed signals for derived state

Migration Notes:
- v1.0.0: Initial release using modern Angular patterns
- Uses standalone components by default
- Requires Angular 17+ for signal support and new control flow
- Compatible with Angular CDK for focus management

Related Components / Patterns:
- Angular CDK A11y module for focus management
- Similar to Angular Material Tabs but with more customization options
- Can be combined with Card components for elevated tab panels
- Works well with Router for navigation-based tabs
- Compatible with Form components for multi-step forms

Changelog:
- v1.0.0: Initial release with signal-based architecture, keyboard navigation, and accessibility support

-----------------------------------------------------------

## File: ./projects/core/components/table/table.txt

Table - Component Documentation
Status: stable
Since: v1.0.0

Short description: A flexible, data-driven table component for displaying tabular data with support for custom column templates, sorting, and row actions.

Purpose and Overview:
The Table component provides a comprehensive solution for displaying tabular data with customizable columns, headers, and cell templates. Built on top of Angular CDK's table, it offers features like row selection, sorting, sticky headers, and action columns. The component is designed to be flexible and performant, using modern Angular patterns including signals for reactive state management, OnPush change detection, and content projection for column definitions. It solves the problem of creating consistent, accessible, and feature-rich data tables across the application while maintaining excellent performance through optimized change detection and virtual scrolling capabilities.

Quick Start:
  Import:
    import { TableModule } from '@kebormed/x-core/components/table';
    @NgModule({
      imports: [TableModule]
    })
    export class DemoModule {}

  Minimal usage (HTML):
    <kbm-table [data]="items">
      <kbm-column field="name" header="Name"></kbm-column>
      <kbm-column field="age" header="Age"></kbm-column>
      <kbm-column field="email" header="Email"></kbm-column>
    </kbm-table>

Inputs and Outputs:
- @Input() data: readonly T[] = []
  Description: Sets the data array to display in the table. Accepts any array of objects with consistent structure.

- @Input() noDataLabel: KbmOptional<string>
  Description: Sets the label to display when the data array is empty. If not provided, no empty state message is shown.

- @Input() activeRow: (row: Readonly<T>) => boolean = () => false
  Description: Function to determine if a row should be marked as active. Receives a frozen copy of the row data and returns boolean.

- @Output() kbmRowClick: EventEmitter<RowClickEvent<T>>
  Description: Emitted when a row is clicked. Only available when kbmRowClick directive is applied. Payload includes row data and metadata (index, first, last, count, odd, even).

Slots and Content Projection:
The table component uses content projection to define columns through kbm-column components:

- <kbm-column>: Defines a column in the table
  - field: string - Unique identifier for the column
  - header: string - Header text to display
  - width: number - Column width in pixels
  - align: 'left' | 'right' | 'center' - Text alignment
  - noClick: boolean - Disables row click events for this column
  - kbmColumnSort: string - Enables sorting for this column
  - Default content: Used as the cell template for the column
  - <ng-template>: Custom cell template with access to row data and metadata

Styling and Theming:
The table component provides extensive customization through CSS custom properties:

Table Properties:
- --kbm-table-width: Sets table width (default: 100%)
- --kbm-table-font-size: Sets font size (default: 0.75rem)
- --kbm-table-layout: Sets table layout (default: fixed)

Header Properties:
- --kbm-table-heading-color: Header text color (default: #000)
- --kbm-table-heading-font-size: Header font size
- --kbm-table-heading-font-weight: Header font weight (default: 700)
- --kbm-table-heading-height: Header row height (default: 40px)
- --kbm-table-heading-border-bottom: Header bottom border (default: none)
- --kbm-table-heading-background-color: Header background (default: #f2f2f2)
- --kbm-table-heading-cell-padding: Header cell padding (default: 0 10px)

Row Properties:
- --kbm-table-row-background-color: Even row background (default: #f2f2f2)
- --kbm-table-row-height: Even row height (default: 40px)
- --kbm-table-row-border-bottom: Even row border (default: none)
- --kbm-table-row-radius: Even row border radius (default: 0)
- --kbm-table-odd-row-background-color: Odd row background (default: #fff)
- --kbm-table-odd-font-color: Odd row text color (default: #000)
- --kbm-table-odd-row-height: Odd row height (default: 20px)
- --kbm-table-odd-row-border-bottom: Odd row border (default: none)
- --kbm-table-odd-row-radius: Odd row border radius (default: 0)
- --kbm-table-active-row-background-color: Active row background (default: #efefef)
- --kbm-table-active-font-color: Active row text color (default: #000)
- --kbm-table-cell-padding: Data cell padding (default: 0 10px)

Responsive behavior: The table uses fixed layout by default with text overflow ellipsis for long content. Sticky headers are supported through the .table-sticky wrapper class.

Accessibility:
- Keyboard: Uses Angular CDK Table which provides full keyboard navigation support including arrow key navigation and focus management
- ARIA: Utilizes semantic HTML table elements (<table>, <tr>, <th>, <td>) for proper screen reader support. Row metadata is available to assistive technologies
- Color contrast: Default colors provide sufficient contrast, but custom themes should ensure WCAG AA compliance (4.5:1 ratio minimum)

Visual Examples:
Basic usage and variants:
  - Basic Table:
    <kbm-table [data]="users">
      <kbm-column field="name" header="Name"></kbm-column>
      <kbm-column field="email" header="Email"></kbm-column>
    </kbm-table>

  - With Custom Cell Templates:
    <kbm-table [data]="users">
      <kbm-column field="name" header="Name">
        <ng-template let-user>
          <strong>{{ user.name }}</strong>
        </ng-template>
      </kbm-column>
    </kbm-table>

  - With Row Click Events:
    <kbm-table [data]="users" kbmRowClick (kbmRowClick)="onRowClick($event)">
      <kbm-column field="name" header="Name"></kbm-column>
    </kbm-table>

  - With Sorting:
    <kbm-table [data]="users">
      <kbm-column field="name" header="Name" kbmColumnSort></kbm-column>
    </kbm-table>

  - With Action Column:
    <kbm-table [data]="users">
      <kbm-column field="name" header="Name"></kbm-column>
      <kbm-column field="action" header="Actions" [kbmActionTemplate]="actionTpl"></kbm-column>
    </kbm-table>

  - Empty State:
    <kbm-table [data]="[]" noDataLabel="No data available"></kbm-table>

  - Active Row State:
    <kbm-table [data]="users" [activeRow]="isUserSelected"></kbm-table>

Behaviors and Lifecycle:
The table component implements several performance optimizations and lifecycle behaviors:
- Uses OnPush change detection strategy for optimal performance
- Leverages Angular signals (computed, contentChildren) for reactive state management
- Provides row metadata (index, first, last, count, odd, even) to cell templates for conditional rendering
- Supports content projection for flexible column definitions
- Implements click event delegation with support for disabling clicks on specific columns
- Uses Angular CDK Table for virtual scrolling capabilities and accessibility features
- Freezes row objects passed to activeRow predicate to prevent mutations
- Runs outside Angular zone for performance-critical operations

API Reference:
  Exports:
    export class TableComponent<T> {
      @Input() noDataLabel: KbmOptional<string>;
      @Input() data: readonly T[] = [];
      @Input() activeRow: (row: Readonly<T>) => boolean = () => false;

      protected readonly columns: Signal<Column<T>[]>;
      protected readonly displayedColumns: Signal<string[]>;
      protected readonly columnLength: Signal<number>;
      protected readonly hasRowClick: Signal<boolean>;

      handleRowClick($event: MouseEvent, data: RowClickEvent<T>): void;
      protected isActive(row: T, predicate: (row: T) => boolean): boolean;
      protected createCellContext(row: T, column: Column<T>, meta: RowMeta): ContextWithImplicit<T> & { column: Column<T>; meta: RowMeta };
      protected createPublicCellContext(row: T, meta: RowMeta): ContextWithImplicit<T> & { meta: RowMeta };
    }

    export abstract class Column<T> {
      abstract getField(): string;
      abstract isSortable(): boolean;
      abstract hasCellTemplate: boolean;
      abstract action: KbmNullable<ActionTemplateDirective<ContextWithImplicit<T>>>;
      abstract noClick: boolean;
      abstract width: KbmOptional<number>;
      abstract align: 'left' | 'right' | 'center';
      abstract defaultHeaderTpl: TemplateRef<ContextWithImplicit<string>>;
      abstract cellTemplate: Signal<KbmNullable<TemplateRef<ContextWithImplicit<T>>>>;
    }

    export class RowClickDirective<T> {
      @Output() kbmRowClick = new EventEmitter<RowClickEvent<T>>();
    }

    export type RowMeta = {
      index: number;
      first: boolean;
      last: boolean;
      count: number;
      odd: boolean;
      even: boolean;
    };

    export class RowClickEvent<T> {
      constructor(
        public readonly row: T,
        public readonly meta: RowMeta,
      ) {}
    }

    export class BaseTable<T> {
      @Input() actionTemplate: TemplateRef<ContextWithImplicit<T>>;
    }

Best Practices and Gotchas:
- Do: Use the field input to specify which property of the data object to display
- Do: Use custom cell templates for complex cell content or formatting
- Do: Use the kbmColumnSort directive for sortable columns
- Do: Use the kbmRowClick directive for handling row clicks
- Do: Use the noClick input to disable row clicks for specific columns (like action columns)
- Do: Provide meaningful noDataLabel for better user experience
- Do: Use the activeRow function for highlighting selected or important rows
- Do: Leverage row metadata in cell templates for conditional styling or behavior
- Don't: Forget to provide the data input - the table will be empty without it
- Don't: Use complex objects as field values without a custom cell template
- Don't: Mutate the data array directly - use immutable updates for proper change detection
- Don't: Override the table's CSS classes without understanding the layout implications
- Don't: Use the table for non-tabular data - consider other components like lists or cards

Migration Notes:
Not applicable for the initial release.

Related Components / Patterns:
- Sort Component: Used with the table for column sorting functionality
- Pagination Component: Can be used with the table for paginated data display
- Card Component: Can be used to wrap the table for a card-like appearance
- Icon Component: Often used in action columns and headers
- Input Components: Used in conjunction with tables for filtering and search
- Loading Component: Can be used to show loading states while data is being fetched

Changelog:
- v1.0.0: Initial release with basic table functionality, column definitions, row clicking, sorting support, and comprehensive theming options

-----------------------------------------------------------

## File: ./projects/core/const/const.txt

---
title: Constants
status: stable
since: v1.0.0
---

# `@kebormed/x-core/const` • Constants Documentation
> A collection of commonly used constants for date/time formatting and country information.

---

## 1. Purpose & Overview
The Constants module provides a set of predefined constants that can be used throughout the application. It includes default date and time formats for consistent date/time display, as well as a comprehensive list of countries with their names, country codes, and dialing codes. These constants help maintain consistency across the application, reduce duplication of common values, and provide standardized data structures for international applications.

## 2. Quick Start
```ts
// 2.1. Import
import {
  DEFAULT_DATE_FORMAT,
  DEFAULT_TIME_FORMAT,
  DEFAULT_DATE_TIME_FORMAT,
  COUNTRIES
} from '@kebormed/x-core/const';

// 2.2. Usage examples
// Using date format constants
import { formatDate } from '@angular/common';

const today = new Date();
const formattedDate = formatDate(today, DEFAULT_DATE_FORMAT, 'en-US');
const formattedTime = formatDate(today, DEFAULT_TIME_FORMAT, 'en-US');
const formattedDateTime = formatDate(today, DEFAULT_DATE_TIME_FORMAT, 'en-US');

// Using the countries list
const countryOptions = COUNTRIES.map(country => ({
  label: country.name,
  value: country.code
}));

// Find a specific country
const usa = COUNTRIES.find(country => country.code === 'US');
```

## 3. Available Constants

### Date and Time Format Constants
| Name | Type | Value | Description |
|------|------|-------|-------------|
| `DEFAULT_DATE_FORMAT` | `string` | `'MM/dd/yyyy'` | Standard date format for displaying dates in MM/dd/yyyy format |
| `DEFAULT_TIME_FORMAT` | `string` | `'HH:mm'` | Standard time format for displaying times in 24-hour format |
| `DEFAULT_DATE_TIME_FORMAT` | `string` | `'MM/dd/yyyy HH:mm'` | Combined date and time format using the above two formats |

### Country Data Constants
| Name | Type | Description |
|------|------|-------------|
| `COUNTRIES` | `Array<CountryData>` | A comprehensive list of 249 countries with their names, dialing codes, and ISO country codes |

#### CountryData Interface
Each country object in the `COUNTRIES` array has the following structure:
```ts
interface CountryData {
  name: string;      // The full name of the country (e.g., 'United States')
  dial_code: string; // The international dialing code (e.g., '+1')
  code: string;      // The two-letter ISO country code (e.g., 'US')
}
```

## 4. Usage Examples

### Using Date Format Constants in Components
```ts
import { DEFAULT_DATE_FORMAT, DEFAULT_TIME_FORMAT, DEFAULT_DATE_TIME_FORMAT } from '@kebormed/x-core/const';
import { formatDate } from '@angular/common';
import { Component, signal } from '@angular/core';

@Component({
  selector: 'app-date-display',
  template: `
    <div>
      <p>Date: {{ formattedDate() }}</p>
      <p>Time: {{ formattedTime() }}</p>
      <p>Date & Time: {{ formattedDateTime() }}</p>
    </div>
  `
})
export class DateDisplayComponent {
  private currentDate = signal(new Date());

  protected readonly formattedDate = computed(() =>
    formatDate(this.currentDate(), DEFAULT_DATE_FORMAT, 'en-US')
  );

  protected readonly formattedTime = computed(() =>
    formatDate(this.currentDate(), DEFAULT_TIME_FORMAT, 'en-US')
  );

  protected readonly formattedDateTime = computed(() =>
    formatDate(this.currentDate(), DEFAULT_DATE_TIME_FORMAT, 'en-US')
  );

  updateDate() {
    this.currentDate.set(new Date());
  }
}
```

### Using Countries List in Forms
```ts
import { COUNTRIES } from '@kebormed/x-core/const';
import { Component, signal } from '@angular/core';
import { FormControl, ReactiveFormsModule } from '@angular/forms';

@Component({
  selector: 'app-country-selector',
  template: `
    <div>
      <label for="country">Select Country:</label>
      <select id="country" [formControl]="countryControl">
        <option value="">Choose a country...</option>
        @for (country of countries; track country.code) {
          <option [value]="country.code">
            {{ country.name }} ({{ country.dial_code }})
          </option>
        }
      </select>

      @if (selectedCountryInfo(); as info) {
        <div class="country-info">
          <p>Selected: {{ info.name }}</p>
          <p>Code: {{ info.code }}</p>
          <p>Dial Code: {{ info.dial_code }}</p>
        </div>
      }
    </div>
  `,
  imports: [ReactiveFormsModule]
})
export class CountrySelectorComponent {
  protected readonly countries = COUNTRIES;
  protected readonly countryControl = new FormControl('');

  protected readonly selectedCountryInfo = computed(() => {
    const selectedCode = this.countryControl.value;
    return selectedCode ?
      this.countries.find(country => country.code === selectedCode) :
      null;
  });

  // Utility methods
  getCountryByCode(code: string) {
    return this.countries.find(country => country.code === code);
  }

  getDialCode(countryCode: string) {
    const country = this.getCountryByCode(countryCode);
    return country ? country.dial_code : '';
  }

  searchCountriesByName(searchTerm: string) {
    return this.countries.filter(country =>
      country.name.toLowerCase().includes(searchTerm.toLowerCase())
    );
  }
}
```

### Using Constants in Services
```ts
import { DEFAULT_DATE_FORMAT, COUNTRIES } from '@kebormed/x-core/const';
import { Injectable } from '@angular/core';
import { formatDate } from '@angular/common';

@Injectable({
  providedIn: 'root'
})
export class DataFormattingService {

  formatDateForDisplay(date: Date): string {
    return formatDate(date, DEFAULT_DATE_FORMAT, 'en-US');
  }

  getCountryOptions() {
    return COUNTRIES.map(country => ({
      label: `${country.name} (${country.dial_code})`,
      value: country.code
    }));
  }

  validateCountryCode(code: string): boolean {
    return COUNTRIES.some(country => country.code === code);
  }

  getCountriesByRegion(dialCodePrefix: string) {
    return COUNTRIES.filter(country =>
      country.dial_code.startsWith(dialCodePrefix)
    );
  }
}
```

## 5. Best Practices & Gotchas
* Do ✔️ Use these constants instead of hardcoding date formats or country lists throughout your application
* Do ✔️ Consider locale requirements when using date format constants - you may need to provide locale-specific formats
* Do ✔️ Use the COUNTRIES constant for dropdowns, validation, and data consistency
* Do ✔️ Cache country lookups if you're doing frequent searches by code or name
* Don't ❌ Modify the constants at runtime as they are meant to be immutable
* Don't ❌ Assume the COUNTRIES array is sorted in any particular order - sort it yourself if needed
* Don't ❌ Hardcode country codes or dial codes when the COUNTRIES constant is available
* Don't ❌ Use these date formats for API communication - use ISO formats for APIs

## 6. API Reference
<details>
<summary>Exports</summary>

```ts
// Date and Time Format Constants
export const DEFAULT_DATE_FORMAT: string = 'MM/dd/yyyy';
export const DEFAULT_TIME_FORMAT: string = 'HH:mm';
export const DEFAULT_DATE_TIME_FORMAT: string = 'MM/dd/yyyy HH:mm';

// Country Data
export const COUNTRIES: Array<{
  name: string;
  dial_code: string;
  code: string;
}>;

// Type definition for country data (available from @kebormed/x-core/types)
interface CountryData {
  name: string;
  dial_code: string;
  code: string;
}
```
</details>

## 7. Related Components / Patterns
* **Date Pickers** - Use date format constants for consistent date display
* **Time Pickers** - Use time format constants for consistent time display
* **Country Selectors** - Use COUNTRIES constant for dropdown options
* **Phone Number Inputs** - Use COUNTRIES constant for dial code validation and display
* **Address Forms** - Use COUNTRIES constant for country selection in address forms
* **Internationalization (i18n)** - These constants provide a foundation for international applications
* **Form Validation** - Use COUNTRIES constant to validate country codes and dial codes
* **Data Export/Import** - Use these constants to ensure consistent data formatting

## 8. Migration Notes
* **v1.0.0**: Initial release with basic date/time formats and comprehensive country list
* If migrating from hardcoded values, replace all instances of:
  - `'MM/dd/yyyy'` with `DEFAULT_DATE_FORMAT`
  - `'HH:mm'` with `DEFAULT_TIME_FORMAT`
  - Custom country arrays with `COUNTRIES` constant

---

### Changelog
| Version | Changes |
|---------|---------|
| 1.0.0 | Initial release with date/time format constants and comprehensive country list (249 countries) |

-----------------------------------------------------------

## File: ./projects/core/date/date.txt

Date - Module Documentation
Status: stable
Since: v1.0.0

Short description: A flexible date manipulation utility module that provides a consistent interface for date operations across Angular applications.

Purpose and Overview:
The Date module provides a standardized way to work with dates in Angular applications through the adapter pattern. It solves the problem of inconsistent date handling across different parts of an application by offering a unified interface for common date operations. The adapter pattern allows for different date implementations while maintaining a consistent API. The module includes an abstract DateAdapter class and a concrete NativeDateAdapter implementation that uses JavaScript's native Date object with Angular's DatePipe for formatting.

Quick Start:
  Import:
    import { DateAdapter, NativeDateAdapter } from '@kebormed/x-core/date';
    import { KBM_DATE_FORMAT } from '@kebormed/x-core/tokens';

    @Component({
      // ...
      providers: [
        { provide: DateAdapter, useClass: NativeDateAdapter },
        { provide: KBM_DATE_FORMAT, useValue: 'yyyy-MM-dd' } // Optional
      ]
    })
    export class MyComponent {
      constructor(private dateAdapter: DateAdapter) {}

      formatToday(): string {
        const today = new Date();
        return this.dateAdapter.format(today, 'mediumDate');
      }
    }

  Minimal usage:
    const dateAdapter = new NativeDateAdapter();
    const today = new Date();
    const formattedDate = dateAdapter.format(today, 'yyyy-MM-dd');

Inputs and Outputs:
The Date Adapter doesn't have traditional inputs/outputs like components, but it does have injectable dependencies:

- Injectable: LOCALE_ID: string = Browser locale
  Description: Sets the locale used for formatting dates and localized month/day names

- Injectable: KBM_DATE_FORMAT: string = Optional
  Description: Sets the default date format when none is specified in format() method

Slots and Content Projection:
Not applicable - this is a service module, not a component.

Styling and Theming:
Not applicable - this is a service module focused on date manipulation logic.

Accessibility:
Not applicable - this is a service module that provides date manipulation utilities.

Visual Examples:
Not applicable - this is a service module without visual components.

Behaviors and Lifecycle:
The DateAdapter uses Angular's modern dependency injection with the inject() function. The NativeDateAdapter implementation includes error handling in the format() method that falls back to DEFAULT_DATE_FORMAT if an invalid format is provided. The adapter uses Intl.DateTimeFormat for localized month names and includes a protected _format() method for consistent UTC date formatting to avoid year conversion issues with dates before 100 AD.

API Reference:
  Exports:
    export abstract class DateAdapter {
      protected _locale = inject(LOCALE_ID);
      protected _dateFormat = inject(KBM_DATE_FORMAT, {optional: true});

      // Date component getters
      abstract getYear(date: Date): number;
      abstract getMonth(date: Date): number;
      abstract getDate(date: Date): number;
      abstract getDayOfWeek(date: Date): number;

      // Calendar information
      abstract getNumDaysInMonth(date: Date): number;
      abstract getFirstDayOfWeek(): number;
      abstract getDayOfWeekNames(): string[];
      abstract getMonthNames(): string[];

      // Date manipulation
      abstract addMonths(date: Date, months: number): Date;
      abstract addYear(date: Date, year: number): Date;

      // Date comparison
      abstract isSame(date1: Date, date2: Date): boolean;
      abstract inRange(date: Date, startDate: Date, endDate: Date): boolean;

      // Formatting and parsing
      abstract format(date: Date, format: string): string | null;
      abstract parse(date: string, format: string): Date;

      // Implemented methods
      createDate(year: number, month: number, date: number): Date;
      protected _format(dtf: Intl.DateTimeFormat, date: Date): string;
    }

    export class NativeDateAdapter extends DateAdapter {
      // Concrete implementation using JavaScript's native Date object
      // Implements all abstract methods with native Date operations
      // Uses Angular's DatePipe for formatting with error handling
      // Falls back to DEFAULT_DATE_FORMAT on format errors
    }

Best Practices and Gotchas:
- Do: Use the DateAdapter for all date operations to ensure consistent behavior across your application
- Do: Inject the DateAdapter rather than instantiating it directly to allow for different implementations
- Do: Provide a custom KBM_DATE_FORMAT token if you need a specific default format
- Do: Handle potential null returns from the format() method
- Don't: Mix DateAdapter with direct Date manipulations as it may lead to inconsistent behavior
- Don't: Assume a specific date format in string representations; always specify the format when parsing
- Don't: Use format strings that aren't supported by Angular's DatePipe

Migration Notes:
- v1.0.0: Initial release with modern Angular dependency injection using inject() function
- The module uses modern Angular patterns and is compatible with standalone components

Related Components / Patterns:
- DatePickerComponent and RangePickerComponent in @kebormed/x-core/components/date-picker
- DateFormatPipe in @kebormed/x-core/utils/pipes for consistent date formatting
- CalendarComponent in @kebormed/x-core/components/calendar for date selection
- DateRange type in @kebormed/x-core/types for date range operations
- isDateRange utility in @kebormed/x-core/utils/miscellaneous for type checking
- KBM_DATE_FORMAT and KBM_TIME_FORMAT tokens in @kebormed/x-core/tokens
- DEFAULT_DATE_FORMAT constant in @kebormed/x-core/const

Changelog:
- v1.0.0: Initial release with DateAdapter abstract class and NativeDateAdapter implementation

-----------------------------------------------------------

## File: ./projects/core/tokens/tokens.txt

Tokens - Angular Injection Tokens Documentation
Status: stable
Since: v1.0.0

Short description: A collection of Angular injection tokens for configuring and accessing shared resources across the application.

Purpose and Overview:
The tokens module provides a set of Angular injection tokens that enable dependency injection for various configuration options and shared resources. These tokens help maintain consistency across the application, allow for easy customization, and facilitate testing by providing a way to mock dependencies. The module includes tokens for API configuration, page visibility tracking, date/time formatting, and country data access.

Quick Start:
  Import:
    import {
      API_BASE_URL,
      PAGE_VISIBILITY,
      KBM_DATE_FORMAT,
      KBM_TIME_FORMAT,
      COUNTRIES_LIST
    } from '@kebormed/x-core/tokens';

  Minimal usage (TypeScript):
    @Component({
      // ...
    })
    export class MyComponent {
      constructor(
        @Inject(API_BASE_URL) private apiBaseUrl: string,
        @Inject(PAGE_VISIBILITY) private pageVisibility$: Observable<boolean>
      ) {}
    }

  Providing custom values:
    @NgModule({
      // ...
      providers: [
        { provide: API_BASE_URL, useValue: 'https://api.example.com' },
        { provide: KBM_DATE_FORMAT, useValue: 'yyyy-MM-dd' },
        { provide: KBM_TIME_FORMAT, useValue: 'HH:mm:ss' }
      ]
    })
    export class AppModule {}

Inputs and Outputs:
N/A - These are injection tokens, not components with inputs/outputs.

Slots and Content Projection:
N/A - These are injection tokens, not components with content projection.

Styling and Theming:
N/A - These are injection tokens, not visual components.

Accessibility:
N/A - These are injection tokens, not UI components.

Visual Examples:
N/A - These are injection tokens, not visual components.

Behaviors and Lifecycle:
- API_BASE_URL: Provides a configurable base URL for API requests with a default factory
- PAGE_VISIBILITY: Creates a shared Observable that tracks document visibility changes using the Page Visibility API
- KBM_DATE_FORMAT/KBM_TIME_FORMAT: Provide configurable format strings for date/time display
- COUNTRIES_LIST: Provides access to a predefined list of country data

API Reference:
  Exports:
    // API Configuration Token
    export const API_BASE_URL: InjectionToken<string>

    // Page Visibility Token
    export const PAGE_VISIBILITY: InjectionToken<Observable<boolean>>

    // Date/Time Format Tokens
    export const KBM_DATE_FORMAT: InjectionToken<string>
    export const KBM_TIME_FORMAT: InjectionToken<string>

    // Country Data Token
    export const COUNTRIES_LIST: InjectionToken<CountryData[]>

  Token Details:

  API_BASE_URL:
    Type: InjectionToken<string>
    Default: '/api'
    Description: Sets the base URL for API requests. Provided at root level with factory.

    Implementation:
    export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL', {
      providedIn: 'root',
      factory: () => '/api'
    });

    Usage Example:
    @Injectable({ providedIn: 'root' })
    export class ApiService {
      constructor(@Inject(API_BASE_URL) private baseUrl: string) {}

      getUsers() {
        return fetch(`${this.baseUrl}/users`);
      }
    }

  PAGE_VISIBILITY:
    Type: InjectionToken<Observable<boolean>>
    Default: Observable based on document visibility events
    Description: Provides a shared Observable that emits true when document is visible, false when hidden.
    Dependencies: Uses Angular's DOCUMENT token and RxJS operators

    Implementation:
    export const PAGE_VISIBILITY: InjectionToken<Observable<boolean>> = new InjectionToken<Observable<boolean>>(
      'PAGE_VISIBILITY: Shared Observable based on `document visibility changed` event.',
      {
        factory: () => {
          const documentRef = inject(DOCUMENT);
          return fromEvent(documentRef, 'visibilitychange').pipe(
            startWith(0),
            map(() => documentRef.visibilityState !== 'hidden'),
            distinctUntilChanged(),
            shareReplay({refCount: false, bufferSize: 1})
          );
        }
      }
    );

    Usage Example:
    @Component({
      // ...
    })
    export class MyComponent implements OnInit, OnDestroy {
      private destroy$ = new Subject<void>();

      constructor(@Inject(PAGE_VISIBILITY) private pageVisibility$: Observable<boolean>) {}

      ngOnInit() {
        this.pageVisibility$.pipe(
          takeUntil(this.destroy$)
        ).subscribe(isVisible => {
          if (isVisible) {
            console.log('Page is visible, resuming operations');
          } else {
            console.log('Page is hidden, pausing operations');
          }
        });
      }

      ngOnDestroy() {
        this.destroy$.next();
        this.destroy$.complete();
      }
    }

  KBM_DATE_FORMAT:
    Type: InjectionToken<string>
    Default: None (must be provided explicitly)
    Description: Sets the format string for displaying dates in the application.

    Implementation:
    export const KBM_DATE_FORMAT = new InjectionToken<string>('KBM_DATE_FORMAT');

  KBM_TIME_FORMAT:
    Type: InjectionToken<string>
    Default: None (must be provided explicitly)
    Description: Sets the format string for displaying times in the application.

    Implementation:
    export const KBM_TIME_FORMAT = new InjectionToken<string>('KBM_TIME_FORMAT');

    Usage Example (both date/time tokens):
    @NgModule({
      // ...
      providers: [
        { provide: KBM_DATE_FORMAT, useValue: 'yyyy-MM-dd' },
        { provide: KBM_TIME_FORMAT, useValue: 'HH:mm:ss' }
      ]
    })
    export class AppModule {}

    @Component({
      // ...
    })
    export class DateDisplayComponent {
      constructor(
        @Inject(KBM_DATE_FORMAT) public dateFormat: string,
        @Inject(KBM_TIME_FORMAT) public timeFormat: string
      ) {}

      formatDate(date: Date): string {
        return formatDate(date, this.dateFormat, 'en-US');
      }

      formatTime(date: Date): string {
        return formatDate(date, this.timeFormat, 'en-US');
      }
    }

  COUNTRIES_LIST:
    Type: InjectionToken<CountryData[]>
    Default: COUNTRIES constant from @kebormed/x-core/const
    Description: Provides a list of country data for use in dropdowns, forms, etc.
    Dependencies: CountryData type from @kebormed/x-core/types, COUNTRIES from @kebormed/x-core/const

    Implementation:
    export const COUNTRIES_LIST = new InjectionToken<CountryData[]>('COUNTRIES_LIST', {
      providedIn: 'root',
      factory: () => COUNTRIES
    });

    Usage Example:
    @Component({
      selector: 'app-country-selector',
      template: `
        <select>
          @for (country of countries; track country.code) {
            <option [value]="country.code">{{ country.name }}</option>
          }
        </select>
      `
    })
    export class CountrySelectorComponent {
      countries: CountryData[];

      constructor(@Inject(COUNTRIES_LIST) countries: CountryData[]) {
        this.countries = countries;
      }
    }

Best Practices and Gotchas:
- Do: Use injection tokens to make your application more configurable
- Do: Provide default values for tokens when appropriate using factory functions
- Do: Use the `providedIn: 'root'` option for tokens that should be available application-wide
- Do: Use proper TypeScript typing for injection tokens
- Do: Use shareReplay for Observable tokens that should share state across subscribers
- Don't: Create tokens for values that don't need to be configurable or injectable
- Don't: Forget to provide values for tokens that don't have default values (KBM_DATE_FORMAT, KBM_TIME_FORMAT)
- Don't: Inject tokens without proper error handling for missing providers

Migration Notes:
- v1.0.0: Initial release with all core tokens
- All tokens follow Angular's modern injection token patterns
- PAGE_VISIBILITY token uses modern RxJS operators and shareReplay for optimal performance

Related Components / Patterns:
- Dependency Injection: Angular's DI system is the foundation for using injection tokens
- Configuration Services: Often use injection tokens to provide configuration values
- Feature Flags: Can be implemented using injection tokens for toggling features
- @kebormed/x-core/types: Provides CountryData interface used by COUNTRIES_LIST token
- @kebormed/x-core/const: Provides COUNTRIES constant used by COUNTRIES_LIST token
- @kebormed/x-core/utils: May contain utilities that work with these tokens

Changelog:
- v1.0.0: Initial release with API_BASE_URL, PAGE_VISIBILITY, KBM_DATE_FORMAT, KBM_TIME_FORMAT, and COUNTRIES_LIST tokens

-----------------------------------------------------------

## File: ./projects/core/types/types.txt

Types - TypeScript Types Documentation
Status: stable
Since: v1.0.0

Short description: A comprehensive collection of utility types, interfaces, and type definitions for consistent type safety across Angular applications.

Purpose and Overview:
The Types module provides a robust set of reusable TypeScript types and interfaces that enhance type safety and consistency throughout the application. It includes utility types for handling nullable values, type transformations, pagination, API responses, entity management, and Angular-specific contexts. These types help maintain consistency across the application, improve type safety, reduce duplication of common type definitions, and provide better developer experience with enhanced IntelliSense support.

The module addresses common TypeScript patterns such as:
- Nullable and optional value handling
- Type mapping and transformation functions
- API response standardization with pagination support
- Entity identification patterns
- Angular structural directive contexts
- Date range management
- Country data standardization

Quick Start:
  Import:
    import {
      ID,
      KbmNullable,
      KbmMaybe,
      KbmOptional,
      Pagination,
      ApiWrapper,
      CountryData,
      DateRange,
      EntityID
    } from '@kebormed/x-core/types';

  Minimal usage (TypeScript):
    // Basic ID usage
    const userId: ID = 123;
    const documentId: ID = 'doc-abc-123';

    // Nullable types
    const nullableValue: KbmNullable<string> = null;
    const maybeValue: KbmMaybe<number> = undefined;
    const optionalValue: KbmOptional<boolean> = undefined;

    // API response with pagination
    interface User {
      id: ID;
      name: string;
      email: string;
    }

    const response: ApiWrapper<User> = {
      result: [
        { id: 1, name: 'John Doe', email: 'john@example.com' }
      ],
      pagination: {
        total: 100,
        page: 1,
        pageSize: 10
      }
    };

Inputs and Outputs:
N/A - This module exports types and interfaces only, no components with inputs/outputs.

Slots and Content Projection:
N/A - This module contains type definitions only.

Styling and Theming:
N/A - This module contains type definitions only.

Accessibility:
N/A - This module contains type definitions only.

Visual Examples:
N/A - This module contains type definitions only.

Behaviors and Lifecycle:
The types in this module are compile-time constructs that provide type safety and IntelliSense support. They do not have runtime behavior or lifecycle hooks. However, they enable better development experience through:
- Enhanced type checking at compile time
- Better IntelliSense and autocomplete support
- Prevention of common type-related runtime errors
- Consistent API contracts across the application

API Reference:
  Exports:

    // Basic Types
    export type ID = number | string;

    // Utility Function Types
    export type KbmMapper<T extends unknown[], G> = (...args: T) => G;
    export type KbmMatcher<T extends unknown[]> = KbmMapper<T, boolean>;
    export type KbmBooleanHandler<T, G = boolean> = (value: T) => G;

    // Nullable and Optional Types
    export type KbmNullable<T> = T | null;
    export type KbmMaybe<T> = T | null | undefined;
    export type KbmOptional<T> = T | undefined;
    export type KbmNullableObject<T> = {
      [K in keyof T]: KbmNullableObject<T[K]> | null;
    };

    // Type Extraction Utilities
    export type KbmTypeOf<T, K extends keyof T> = K extends keyof T ? T[K] : never;
    export type KbmNullableTypeOf<T, K extends keyof T> = K extends keyof T ? T[K] | null : never;
    export type Entries<T> = { [K in keyof T]: [K, T[K]] }[keyof T][];

    // Pagination Types
    export type PaginationOptions = { pageSize: number; pageSizeOptions: number[] };
    export type Pagination = {
      total: number;
      page: number;
      pageSize: number;
    };
    export type ApiWrapper<T> = {
      result: Array<T>;
      pagination?: Pagination;
    };

    // Entity Types
    export type EntityID = { id: ID };
    export type DateRange = {
      start: Date | null;
      end: Date | null;
    };

    // Angular-specific Types
    export interface ContextWithImplicit<T> {
      $implicit: T;
    }

    // Country Data Interface
    export interface CountryData {
      name: string;
      code: string;
      dial_code: string;
    }

Best Practices and Gotchas:
- Do: Use ID type for all entity identifiers to maintain consistency
- Do: Use KbmNullable<T> instead of T | null for better semantic meaning
- Do: Use KbmMaybe<T> when a value can be null, undefined, or the actual type
- Do: Use ApiWrapper<T> for all paginated API responses to maintain consistency
- Do: Use EntityID interface for entities that require an ID property
- Do: Use DateRange for any date range selections or filters
- Don't: Mix different nullable type patterns in the same codebase
- Don't: Use any instead of proper type definitions from this module
- Don't: Create custom pagination types when ApiWrapper<T> and Pagination are available
- Don't: Use string literals for country codes when CountryData interface is available

Migration Notes:
- v1.0.0: Initial release with core utility types
- When migrating from custom nullable types, replace with KbmNullable<T>, KbmMaybe<T>, or KbmOptional<T>
- When migrating pagination logic, adopt ApiWrapper<T> and Pagination types for consistency
- Replace custom ID types with the standardized ID type (number | string)

Related Components / Patterns:
- Use with @kebormed/x-core/utils/miscellaneous for type guard functions like kbmIsString()
- Combine with @kebormed/x-core/tokens for dependency injection patterns
- Use with @kebormed/x-core/components for consistent typing across UI components
- Integrate with @kebormed/x-core/utils/validation for form validation with proper typing
- Works seamlessly with Angular's reactive forms and signal-based state management

Changelog:
- v1.0.0: Initial release with comprehensive type definitions
  - Added basic utility types (ID, KbmMapper, KbmMatcher, KbmBooleanHandler)
  - Added nullable and optional type utilities
  - Added pagination and API wrapper types
  - Added entity and date range types
  - Added Angular-specific context types
  - Added country data interface

-----------------------------------------------------------

## File: ./projects/core/utils/directives/directives.txt

Directives - Component Documentation
Status: stable
Since: v1.0.0

Short description: A collection of standalone utility directives that provide common functionality for Angular templates, including observable unwrapping and DOM element marking.

Purpose and Overview:
The Directives module provides a set of reusable Angular directives that solve common problems in template development. These directives enhance template functionality by providing utilities for unwrapping observables without conditions (LetDirective) and marking DOM elements for identification and querying (ItemDirective). Both directives are standalone and can be used independently in any Angular application to improve code readability and reduce boilerplate.

Quick Start:
  Import:
    // Specific import
    import { LetDirective, ItemDirective } from '@kebormed/x-core/utils/directives';

    // Or from main library
    import { LetDirective, ItemDirective } from '@kebormed/x-core';

    // For standalone components
    @Component({
      selector: 'app-example',
      imports: [LetDirective, ItemDirective],
      template: `...`
    })
    export class ExampleComponent {}

  Minimal usage (HTML):
    <!-- Let directive usage -->
    <ng-container *kbmLet="data$ | async as data">
      {{data.name}}
    </ng-container>

    <!-- Item directive usage -->
    <div kbmItem>Marked item</div>

Inputs and Outputs:

LetDirective:
- @Input() kbmLet: T
  Description: The value to be stored in the template context. Can be any type T, commonly used with observables and the async pipe.

ItemDirective:
- No inputs or outputs
  Description: A marker directive that doesn't implement any behavior itself but can be used for DOM element identification.

Slots and Content Projection:
The LetDirective works as a structural directive and creates an embedded view with the provided context. The ItemDirective is an attribute directive that can be applied to any element without affecting content projection.

Styling and Theming:
- No specific styling or theming options
- Both directives are purely functional and don't affect visual presentation
- Can be combined with other styling directives and CSS classes

Accessibility:
- Keyboard: No specific keyboard interactions
- ARIA: No ARIA attributes are added by these directives
- Color contrast: Not applicable as these are utility directives without visual impact

Visual Examples:
Basic usage and variants:
  - LetDirective Basic:
    <ng-container *kbmLet="user$ | async as user">
      <div>Name: {{user.name}}</div>
      <div>Email: {{user.email}}</div>
    </ng-container>

  - ItemDirective Basic:
    <kbm-checkbox kbmItem>Option 1</kbm-checkbox>
    <kbm-checkbox kbmItem>Option 2</kbm-checkbox>

  - Combined Usage:
    <ng-container *kbmLet="items$ | async as items">
      @for (item of items; track item.id) {
        <div kbmItem>{{item.name}}</div>
      }
    </ng-container>

Behaviors and Lifecycle:
LetDirective:
- Creates an embedded view immediately in the constructor
- Provides template context with both $implicit and kbmLet properties
- Includes template context guard for type safety
- No lifecycle hooks or performance optimizations needed

ItemDirective:
- Simple marker directive with no lifecycle behavior
- Can be queried using @ViewChildren or @ContentChildren
- Useful for programmatic access to marked elements

API Reference:
  Exports:
    export class LetDirective<T> {
      @Input() kbmLet!: T;

      constructor(
        viewContainer: ViewContainerRef,
        templateRef: TemplateRef<LetContext<T>>
      );

      static ngTemplateContextGuard<T>(
        _dir: LetDirective<T>,
        _ctx: unknown
      ): _ctx is LetContext<T>;
    }

    export class LetContext<T> {
      constructor(private readonly internalDirectiveInstance: LetDirective<T>);
      get $implicit(): T;
      get kbmLet(): T;
    }

    export class ItemDirective {}

Best Practices and Gotchas:

LetDirective:
- Do: Use for unwrapping observables when you don't need a condition
- Do: Consider migrating to Angular's new @let control flow for new code (Angular 17+)
- Do: Use ng-container to avoid adding extra DOM elements
- Don't: Nest multiple *kbmLet directives on the same element
- Don't: Use when *ngIf with async pipe would be more appropriate

ItemDirective:
- Do: Use to mark related items that need to be queried as a group
- Do: Combine with @ViewChildren or @ContentChildren to access marked elements
- Do: Use for programmatic identification of DOM elements
- Don't: Expect any visual or behavioral changes from applying this directive alone
- Don't: Use as a replacement for proper component architecture

Migration Notes:
- LetDirective is marked as deprecated in favor of Angular's new @let control flow (Angular 17+)
- When migrating from LetDirective to @let, replace:
  <ng-container *kbmLet="data$ | async as data">
  with:
  @let data = data$ | async;
- ItemDirective has no breaking changes and remains stable

Related Components / Patterns:
- Angular's @let control flow (replacement for LetDirective)
- *ngIf with async pipe (alternative to LetDirective)
- @ViewChildren and @ContentChildren (used with ItemDirective)
- Structural directives pattern
- Template reference variables

Changelog:
- v1.0.0: Initial release with LetDirective and ItemDirective
- v1.0.0: LetDirective marked as deprecated in favor of Angular's @let control flow

-----------------------------------------------------------

## File: ./projects/core/utils/dom/dom.txt

DOM Utilities - Utility Functions Documentation
Status: stable
Since: v1.0.0

Short description: A collection of utility functions for DOM manipulation and interaction in Angular applications.

Purpose and Overview:
The DOM Utilities module provides a set of helper functions for working with the DOM in Angular applications. These utilities simplify common DOM operations such as accessing native elements, retrieving host attributes, and determining DOM node relationships. They leverage Angular's dependency injection system and modern DOM APIs to provide type-safe and efficient DOM manipulation capabilities. The utilities are designed to work within Angular's injection context and provide better type safety compared to direct DOM manipulation.

Quick Start:
  Import:
    import { kbmInjectElement, kbmHostAttribute, isDescendantOrPreceding } from '@kebormed/x-core/utils/dom';

  Minimal usage (TypeScript):
    @Component({
      selector: 'app-example',
      template: `<div>Example Component</div>`
    })
    export class ExampleComponent {
      // Access the component's native element
      element = kbmInjectElement<HTMLElement>();

      // Get a host attribute with a default value
      theme = kbmHostAttribute<string>('theme', 'default');

      // Check DOM node relationships
      checkRelationship(node1: Node, node2: Node): boolean {
        return isDescendantOrPreceding(node1, node2);
      }
    }

Inputs and Outputs:
- kbmInjectElement<T = HTMLElement>(): T
  Description: Injects and returns the native DOM element of the component. Generic type parameter T defaults to HTMLElement for better type safety.

- kbmHostAttribute<R>(key: string, defaultValue: R): R
  Description: Retrieves a host attribute value by key with a fallback default value. Uses Angular's HostAttributeToken internally.

- kbmHostAttribute.required<R>(key: string): R
  Description: Retrieves a required host attribute value by key. Throws an error if the attribute is not found.

- isDescendantOrPreceding(referenceNode: Node, targetNode: Node): boolean
  Description: Determines if a target node is either a descendant of the reference node or precedes it in the document order.

Slots and Content Projection:
Not applicable - these are utility functions, not components with templates.

Styling and Theming:
Not applicable - these utilities do not provide styling capabilities but can be used to access elements for styling purposes.

Accessibility:
- These utilities can be used to implement accessibility features by providing direct access to DOM elements
- kbmHostAttribute can be used to read accessibility-related attributes like aria-* attributes
- isDescendantOrPreceding can help with focus management and keyboard navigation

Visual Examples:
Basic usage and variants:
  - DOM Element Access:
    ```ts
    @Component({
      selector: 'app-example',
      template: `<div>Example Component</div>`
    })
    export class ExampleComponent implements AfterViewInit {
      element = kbmInjectElement<HTMLDivElement>();

      ngAfterViewInit() {
        this.element.classList.add('highlighted');
      }
    }
    ```

  - Host Attribute Reading:
    ```ts
    @Component({
      selector: 'app-themed-component',
      template: `<div [class]="theme">Themed content</div>`
    })
    export class ThemedComponent {
      theme = kbmHostAttribute<string>('theme', 'default');
      id = kbmHostAttribute.required<string>('id');
    }
    ```

  - DOM Node Relationship Checking:
    ```ts
    @Component({
      selector: 'app-node-checker',
      template: `
        <div #container>
          <div #child>Child element</div>
        </div>
        <div #sibling>Sibling element</div>
      `
    })
    export class NodeCheckerComponent implements AfterViewInit {
      @ViewChild('container') container!: ElementRef;
      @ViewChild('child') child!: ElementRef;
      @ViewChild('sibling') sibling!: ElementRef;

      ngAfterViewInit() {
        // Check if child is a descendant of container (true)
        console.log(isDescendantOrPreceding(
          this.container.nativeElement,
          this.child.nativeElement
        ));

        // Check if sibling is a descendant of container (false)
        console.log(isDescendantOrPreceding(
          this.container.nativeElement,
          this.sibling.nativeElement
        ));
      }
    }
    ```

Behaviors and Lifecycle:
- kbmInjectElement: Must be called within an injection context (component constructor or initialization)
- kbmHostAttribute: Uses assertInInjectionContext to ensure proper usage context
- isDescendantOrPreceding: Can be called at any time, includes error handling with try-catch block
- All functions are designed to work with Angular's dependency injection system

API Reference:
  Exports:
    export function kbmInjectElement<T = HTMLElement>(): T;

    export function kbmHostAttribute<R>(key: string, defaultValue: R): R;
    export namespace kbmHostAttribute {
      export function required<R>(key: string): R;
    }

    export function isDescendantOrPreceding(referenceNode: Node, targetNode: Node): boolean;

  Implementation Details:
    - kbmInjectElement: Uses inject(ElementRef).nativeElement internally
    - kbmHostAttribute: Uses inject(new HostAttributeToken(key), {optional: true}) with nullish coalescing
    - kbmHostAttribute.required: Uses inject(new HostAttributeToken(key)) without optional flag
    - isDescendantOrPreceding: Uses Node.contains() and Node.compareDocumentPosition() with DOCUMENT_POSITION_PRECEDING flag

Best Practices and Gotchas:
- Do: Use kbmInjectElement() instead of injecting ElementRef and accessing .nativeElement
- Do: Provide appropriate type parameters to kbmInjectElement<T>() for better type safety
- Do: Always provide a sensible default value when using kbmHostAttribute()
- Do: Use kbmHostAttribute.required() only when the attribute is guaranteed to exist
- Do: Call these functions within Angular's injection context (constructor or initialization)
- Don't: Use isDescendantOrPreceding() with nodes from different documents
- Don't: Call these utility functions outside of an injection context
- Don't: Assume kbmHostAttribute.required() will never throw - handle potential errors appropriately

Migration Notes:
- v1.0.0: Initial release - no migration needed
- These utilities replace direct ElementRef injection and manual host attribute reading
- When migrating from ElementRef usage, replace inject(ElementRef).nativeElement with kbmInjectElement()

Related Components / Patterns:
- Angular's ElementRef and Renderer2 for DOM manipulation
- Angular's dependency injection system and inject() function
- Angular's HostAttributeToken for host attribute access
- Host binding and host listeners in Angular components
- DOM APIs: Node.contains(), Node.compareDocumentPosition()

Changelog:
- v1.0.0: Initial release with kbmInjectElement, kbmHostAttribute, and isDescendantOrPreceding functions

-----------------------------------------------------------

## File: ./projects/core/utils/miscellaneous/miscellaneous.txt

Miscellaneous Utilities - Utility Functions Documentation
Status: stable
Since: v1.0.0

Short description: A comprehensive collection of utility functions for type checking, array operations, object manipulations, string generation, file operations, and other common programming tasks.

Purpose and Overview:
The Miscellaneous Utilities module provides a robust set of helper functions that simplify common programming tasks in Angular applications. These utilities include type checking functions with TypeScript type guards, array manipulation functions for filtering and transforming data, object transformation utilities for working with Maps and nested properties, mathematical operations, string generation, file saving capabilities, and various other helper functions. The utilities are designed to reduce boilerplate code, provide consistent implementations for frequently needed operations, and enhance type safety through TypeScript type guards. They work seamlessly with Angular's dependency injection system and modern TypeScript patterns.

Quick Start:
  Import:
    import {
      kbmIsString,
      kbmIsNumber,
      kbmIsArray,
      kbmRandomString,
      saveAs,
      kbmUniqueBy,
      kbmGroupBy,
      kbmAssert,
      kbmOnlyPresentValues
    } from '@kebormed/x-core/utils/miscellaneous';

  Minimal usage (TypeScript):
    // Type checking with type guards
    const data: unknown = 'Hello, world!';
    if (kbmIsString(data)) {
      console.log(data.length); // TypeScript knows data is a string
    }

    // Array operations
    const users = [
      { id: 1, name: 'Alice' },
      { id: 2, name: 'Bob' },
      { id: 1, name: 'Alice (duplicate)' }
    ];
    const uniqueUsers = kbmUniqueBy(users, 'id');

    // Generate random string
    const randomId = kbmRandomString();

    // Save file
    const blob = new Blob(['Hello, world!'], { type: 'text/plain' });
    saveAs(blob, 'example.txt');

Inputs and Outputs:
Type Checking Functions:
- kbmIsString(value: unknown): value is string
  Description: Checks if a value is a string and acts as a TypeScript type guard.

- kbmIsNumber(value: unknown): value is number
  Description: Checks if a value is a number and acts as a TypeScript type guard.

- kbmIsBoolean(value: unknown): value is boolean
  Description: Checks if a value is a boolean and acts as a TypeScript type guard.

- kbmIsObject(value: unknown): value is object
  Description: Checks if a value is an object and acts as a TypeScript type guard.

- kbmIsFunction(value: unknown): value is Function
  Description: Checks if a value is a function and acts as a TypeScript type guard.

- kbmIsArray(value: unknown): value is any[]
  Description: Checks if a value is an array and acts as a TypeScript type guard.

- kbmIsNil(value: unknown): value is null | undefined
  Description: Checks if a value is null or undefined and acts as a TypeScript type guard.

- kbmIsPresent(value: unknown): boolean
  Description: Checks if a value is not null or undefined.

- kbmIsEmpty(value: unknown): boolean
  Description: Checks if a value is empty (null, undefined, empty string, empty array, or empty object).

- kbmIsDateRange(value: unknown): boolean
  Description: Checks if a value is a valid date range object with start and end properties.

Array Manipulation Functions:
- kbmArrayRemove<T>(array: T[], item: T): T[]
  Description: Removes an item from an array and returns a new array without modifying the original.

- kbmUniqueBy<T>(array: T[], key: keyof T): T[]
  Description: Returns a new array with duplicates removed based on a specified key property.

- kbmFilterBy<T>(array: T[], key: keyof T, value: any): T[]
  Description: Filters an array by matching a key-value pair and returns a new array.

- kbmGroupBy<T>(array: T[], key: keyof T): Record<string, T[]>
  Description: Groups an array of objects by a specified key and returns a record of grouped items.

Object Manipulation Functions:
- kbmMapToObject<K, V>(map: Map<K, V>): Record<string, V>
  Description: Converts a Map to a plain object with string keys.

- kbmMapToArray<K, V>(map: Map<K, V>): Array<{ key: K, value: V }>
  Description: Converts a Map to an array of key-value pair objects.

- kbmTransformMap<K, V, R>(map: Map<K, V>, transformFn: (value: V, key: K) => R): Map<K, R>
  Description: Transforms the values in a Map using a transformation function and returns a new Map.

- kbmNestedPathResolver(obj: any, path: string): any
  Description: Resolves a nested property path in an object using dot notation (e.g., 'user.profile.name').

- kbmOnlyPresentValues(obj: Record<string, any>): Record<string, any>
  Description: Returns a new object containing only properties with non-null and non-undefined values.

- kbmProvideOptions<T>(options: Partial<T>, defaults: T): T
  Description: Merges provided options with default values, returning a complete configuration object.

Utility Functions:
- kbmRandomString(): string
  Description: Generates a random alphanumeric string using base-36 encoding.

- saveAs(data: Blob, name: string): void
  Description: Triggers a download of a Blob object as a file with the specified name.

- kbmAssert(condition: boolean, message: string): void
  Description: Throws an error with the specified message if the condition is false.

- kbmIdGenerator(): () => string
  Description: Returns a function that generates unique sequential IDs.

Mathematical Functions:
- Various mathematical utility functions for common calculations and operations.

Empty Value Functions:
- Utility functions for handling and checking empty values in different contexts.

Slots and Content Projection:
Not applicable - these are utility functions, not components with templates.

Styling and Theming:
Not applicable - these utilities do not provide styling capabilities but can be used to manipulate data for styling purposes.

Accessibility:
- These utilities can be used to implement accessibility features by providing type-safe data manipulation
- Type checking functions help ensure proper data types for accessibility attributes
- Array and object utilities can help organize accessibility-related data structures

Visual Examples:
Basic usage and variants:
  - Type Checking:
    function processValue(value: unknown) {
      if (kbmIsString(value)) {
        return value.toUpperCase(); // TypeScript knows value is string
      } else if (kbmIsNumber(value)) {
        return value.toFixed(2); // TypeScript knows value is number
      } else if (kbmIsArray(value)) {
        return value.length; // TypeScript knows value is array
      }
      return 'Unsupported type';
    }

  - Array Operations:
    const users = [
      { id: 1, name: 'Alice', role: 'admin' },
      { id: 2, name: 'Bob', role: 'user' },
      { id: 1, name: 'Alice (duplicate)', role: 'admin' }
    ];

    // Remove duplicates by ID
    const uniqueUsers = kbmUniqueBy(users, 'id');

    // Group by role
    const usersByRole = kbmGroupBy(users, 'role');

    // Filter by role
    const admins = kbmFilterBy(users, 'role', 'admin');

  - Object Operations:
    const userMap = new Map([
      ['user1', { name: 'Alice', age: 30 }],
      ['user2', { name: 'Bob', age: 25 }]
    ]);

    // Convert to object
    const userObject = kbmMapToObject(userMap);

    // Convert to array
    const userArray = kbmMapToArray(userMap);

    // Transform values
    const ageMap = kbmTransformMap(userMap, (user) => user.age);

  - File Operations:
    // Save text file
    const textBlob = new Blob(['Hello, world!'], { type: 'text/plain' });
    saveAs(textBlob, 'greeting.txt');

    // Save JSON file
    const data = { users: ['Alice', 'Bob'] };
    const jsonBlob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
    saveAs(jsonBlob, 'users.json');

  - Utility Operations:
    // Generate random IDs
    const randomId = kbmRandomString();

    // Create ID generator
    const generateId = kbmIdGenerator();
    const id1 = generateId(); // Returns sequential ID
    const id2 = generateId(); // Returns next sequential ID

    // Assert conditions
    kbmAssert(users.length > 0, 'Users array cannot be empty');

    // Clean object of empty values
    const dirtyData = { name: 'Alice', age: null, email: undefined, active: true };
    const cleanData = kbmOnlyPresentValues(dirtyData); // { name: 'Alice', active: true }

Behaviors and Lifecycle:
- Type checking functions: Execute immediately and return boolean results with type narrowing
- Array manipulation functions: Create new arrays without modifying originals (immutable operations)
- Object manipulation functions: Work with Maps and plain objects, returning new instances
- File operations: Interact with browser APIs to trigger downloads
- Utility functions: Provide various helper capabilities with different execution patterns
- All functions are pure (except saveAs and kbmAssert) and can be called at any time
- No Angular-specific lifecycle dependencies, but work seamlessly within Angular applications

API Reference:
  Exports:
    // Type Checking Functions
    export function kbmIsString(value: unknown): value is string;
    export function kbmIsNumber(value: unknown): value is number;
    export function kbmIsBoolean(value: unknown): value is boolean;
    export function kbmIsObject(value: unknown): value is object;
    export function kbmIsFunction(value: unknown): value is Function;
    export function kbmIsArray(value: unknown): value is any[];
    export function kbmIsNil(value: unknown): value is null | undefined;
    export function kbmIsPresent(value: unknown): boolean;
    export function kbmIsEmpty(value: unknown): boolean;
    export function kbmIsDateRange(value: unknown): boolean;

    // Array Manipulation Functions
    export function kbmArrayRemove<T>(array: T[], item: T): T[];
    export function kbmUniqueBy<T>(array: T[], key: keyof T): T[];
    export function kbmFilterBy<T>(array: T[], key: keyof T, value: any): T[];
    export function kbmGroupBy<T>(array: T[], key: keyof T): Record<string, T[]>;

    // Object Manipulation Functions
    export function kbmMapToObject<K, V>(map: Map<K, V>): Record<string, V>;
    export function kbmMapToArray<K, V>(map: Map<K, V>): Array<{ key: K, value: V }>;
    export function kbmTransformMap<K, V, R>(map: Map<K, V>, transformFn: (value: V, key: K) => R): Map<K, R>;
    export function kbmNestedPathResolver(obj: any, path: string): any;
    export function kbmOnlyPresentValues(obj: Record<string, any>): Record<string, any>;
    export function kbmProvideOptions<T>(options: Partial<T>, defaults: T): T;

    // Utility Functions
    export function kbmRandomString(): string;
    export function saveAs(data: Blob, name: string): void;
    export function kbmAssert(condition: boolean, message: string): void;
    export function kbmIdGenerator(): () => string;

    // Mathematical Functions
    export * from './math';

    // Empty Value Functions
    export * from './empty';

  Implementation Details:
    - Type checking functions use typeof operator and other JavaScript type checking mechanisms
    - Array functions use modern JavaScript array methods with immutable patterns
    - Object functions work with Map API and object manipulation techniques
    - saveAs function uses URL.createObjectURL and anchor element click simulation
    - kbmRandomString uses Math.random().toString(36).slice(2) for alphanumeric generation
    - All functions are designed for optimal performance and type safety

Best Practices and Gotchas:
- Do: Use type checking utilities to ensure type safety, especially with data from external sources
- Do: Leverage TypeScript type guards provided by type checking functions for better type inference
- Do: Use array utilities to write more concise and readable code with immutable operations
- Do: Use object utilities for consistent Map and object transformations
- Do: Use saveAs for client-side file downloads instead of creating custom implementations
- Do: Use kbmAssert for development-time condition checking and debugging
- Do: Use kbmOnlyPresentValues to clean API payloads of null/undefined values
- Don't: Modify original arrays or objects when using utilities that return new instances
- Don't: Assume type checking utilities perform data validation beyond their specific type checks
- Don't: Use kbmAssert in production code for user-facing error handling
- Don't: Rely on kbmRandomString for cryptographically secure random values
- Don't: Use saveAs in server-side rendering contexts where document is not available

Migration Notes:
- v1.0.0: Initial release with comprehensive utility functions
- When migrating from custom type checking, replace with kbmIsString, kbmIsNumber, etc.
- When migrating array operations, adopt immutable patterns provided by these utilities
- Replace custom file download implementations with saveAs function
- Use kbmOnlyPresentValues instead of manual object property filtering

Related Components / Patterns:
- @kebormed/x-core/types: Provides type definitions that work with these utilities (ID, KbmNullable, etc.)
- @kebormed/x-core/tokens: Injection tokens that may use these utilities for configuration
- @kebormed/x-core/utils/dom: DOM utilities that complement these general-purpose utilities
- @kebormed/x-core/utils/validation: Form validation utilities that may use type checking functions
- @kebormed/x-core/components: UI components that may use these utilities for data manipulation
- Angular's reactive forms and signal-based state management work well with these utilities
- RxJS operators can be combined with these utilities for reactive data transformations

Changelog:
- v1.0.0: Initial release with comprehensive utility functions
  - Added type checking functions with TypeScript type guards
  - Added array manipulation functions for filtering, grouping, and deduplication
  - Added object manipulation functions for Map conversions and nested property access
  - Added file operations with saveAs function
  - Added utility functions for random string generation, assertions, and ID generation
  - Added mathematical utility functions
  - Added empty value handling functions

-----------------------------------------------------------

## File: ./projects/core/utils/pipes/pipes.txt

Pipes - Utility Pipes Documentation
Status: stable
Since: v1.0.0

Short description: A collection of utility pipes for data transformation and formatting in Angular applications.

Purpose and Overview:
The Pipes module provides a set of reusable Angular pipes that simplify common data transformation tasks in templates. These pipes include generic mapping and filtering capabilities, boolean-to-text conversion, and date/time formatting with configurable formats. The pipes leverage Angular's dependency injection system and modern TypeScript features to provide type-safe transformations. They are designed to work seamlessly with the core type system and token-based configuration, enabling consistent data presentation across the application while maintaining flexibility and reusability.

Quick Start:
  Import:
    import { MapperPipe, FilterPipe, BooleanToValuePipe, DateFormatPipe, TimeFormatPipe } from '@kebormed/x-core/utils/pipes';

  Minimal usage (HTML):
    <!-- Mapper pipe -->
    <div>{{ someValue | mapper: myMapperFunction: arg1: arg2 }}</div>

    <!-- Filter pipe -->
    <div *ngFor="let item of items | filter: filterFunction: arg1">{{ item }}</div>

    <!-- Boolean to value pipe -->
    <span>{{ isActive | booleanToValue:'Active':'Inactive' }}</span>

    <!-- Date format pipe -->
    <span>{{ dateValue | dateFormat }}</span>
    <span>{{ dateValue | dateFormat: true }}</span>

    <!-- Time format pipe -->
    <span>{{ timeValue | timeFormat }}</span>

Inputs and Outputs:
- MapperPipe.transform<T, U, G>(value: U, mapper: KbmMapper<[U, ...T], G>, ...args: T): G
  Description: Applies a mapping function to a value with additional arguments. Uses KbmMapper type for type safety.

- FilterPipe.transform<T, U>(items: readonly T[], predicate: KbmMatcher<[T, ...U]>, ...args: U): T[]
  Description: Filters an array based on a predicate function. Returns empty array if input is not an array. Uses KbmMatcher type for predicate functions.

- BooleanToValuePipe.transform(value: boolean | null | undefined, trueText: string = 'Yes', falseText: string = 'No'): string
  Description: Transforms boolean values into custom text representations. Uses Angular CDK's coerceBooleanProperty for robust boolean coercion.

- DateFormatPipe.transform(value: Parameters<Intl.DateTimeFormat['format']>[0], withTime: boolean = false): string | null
  Description: Formats dates using configurable date and time formats. Returns null for falsy values. Combines date and time formats when withTime is true.

- TimeFormatPipe.transform(value: Parameters<Intl.DateTimeFormat['format']>[0]): string | null
  Description: Formats time values using configurable time format. Uses Angular's DatePipe internally with locale support.

Slots and Content Projection:
Not applicable - these are utility pipes, not components with templates.

Styling and Theming:
Not applicable - these pipes transform data and do not provide styling capabilities.

Accessibility:
- These pipes can enhance accessibility by providing consistent, readable text representations of data
- BooleanToValuePipe helps create screen-reader friendly boolean representations
- Date and time pipes ensure consistent, locale-aware formatting for temporal data
- All pipes maintain semantic meaning of the original data while improving presentation

Visual Examples:
Basic usage and variants:
  - Mapper Pipe Usage:
    ```ts
    @Component({
      template: `
        <div>{{ user | mapper: getUserDisplayName: showEmail }}</div>
        <div>{{ price | mapper: formatCurrency: 'USD' }}</div>
      `
    })
    export class ExampleComponent {
      user = { name: 'John', email: 'john@example.com' };
      price = 29.99;
      showEmail = true;

      getUserDisplayName = (user: any, showEmail: boolean) =>
        showEmail ? `${user.name} (${user.email})` : user.name;

      formatCurrency = (amount: number, currency: string) =>
        new Intl.NumberFormat('en-US', { style: 'currency', currency }).format(amount);
    }
    ```

  - Filter Pipe Usage:
    ```ts
    @Component({
      template: `
        <div *ngFor="let item of items | filter: isActive">{{ item.name }}</div>
        <div *ngFor="let user of users | filter: hasRole: 'admin'">{{ user.name }}</div>
      `
    })
    export class FilterExampleComponent {
      items = [
        { name: 'Item 1', active: true },
        { name: 'Item 2', active: false }
      ];
      users = [
        { name: 'John', role: 'admin' },
        { name: 'Jane', role: 'user' }
      ];

      isActive = (item: any) => item.active;
      hasRole = (user: any, role: string) => user.role === role;
    }
    ```

  - Boolean to Value Pipe Usage:
    ```ts
    @Component({
      template: `
        <span>Status: {{ isOnline | booleanToValue:'Online':'Offline' }}</span>
        <span>Active: {{ isActive | booleanToValue }}</span>
        <span>Verified: {{ isVerified | booleanToValue:'✓':'✗' }}</span>
      `
    })
    export class BooleanExampleComponent {
      isOnline = true;
      isActive = false;
      isVerified = null; // Will be coerced to false
    }
    ```

  - Date and Time Pipe Usage:
    ```ts
    @Component({
      template: `
        <div>Date: {{ currentDate | dateFormat }}</div>
        <div>Date with time: {{ currentDate | dateFormat: true }}</div>
        <div>Time only: {{ currentDate | timeFormat }}</div>
      `
    })
    export class DateExampleComponent {
      currentDate = new Date();
    }
    ```

Behaviors and Lifecycle:
- MapperPipe: Pure pipe that recalculates only when inputs change. Mapper function should be pure for optimal performance.
- FilterPipe: Pure pipe that uses kbmIsArray utility for safe array checking. Returns empty array for non-array inputs.
- BooleanToValuePipe: Pure pipe that uses coerceBooleanProperty for consistent boolean coercion, handling null and undefined values.
- DateFormatPipe: Pure pipe that injects locale and format tokens. Combines date and time formats based on withTime parameter.
- TimeFormatPipe: Pure pipe that injects locale and time format token. Uses Angular's DatePipe internally for consistent formatting.
- All pipes leverage Angular's dependency injection and are designed for optimal change detection performance.

API Reference:
  Exports:
    export class MapperPipe implements PipeTransform {
      transform<T extends unknown[], U, G>(value: U, mapper: KbmMapper<[U, ...T], G>, ...args: T): G;
    }

    export class FilterPipe implements PipeTransform {
      transform<T, U extends unknown[]>(items: readonly T[], predicate: KbmMatcher<[T, ...U]>, ...args: U): T[];
    }

    export class BooleanToValuePipe implements PipeTransform {
      transform(value: boolean | null | undefined, trueText?: string, falseText?: string): string;
    }

    export class DateFormatPipe implements PipeTransform {
      transform(value: Parameters<Intl.DateTimeFormat['format']>[0], withTime?: boolean): string | null;
    }

    export class TimeFormatPipe implements PipeTransform {
      transform(value: Parameters<Intl.DateTimeFormat['format']>[0]): string | null;
    }

  Dependencies:
    - KbmMapper, KbmMatcher types from @kebormed/x-core/types
    - kbmIsArray utility from @kebormed/x-core/utils/miscellaneous
    - KBM_DATE_FORMAT, KBM_TIME_FORMAT tokens from @kebormed/x-core/tokens
    - DEFAULT_DATE_FORMAT, DEFAULT_TIME_FORMAT constants from @kebormed/x-core/const
    - Angular CDK coerceBooleanProperty for boolean coercion
    - Angular DatePipe and LOCALE_ID for date/time formatting

Best Practices and Gotchas:
- Do: Use MapperPipe with pure functions for optimal performance and predictable results
- Do: Provide meaningful default values for BooleanToValuePipe text parameters
- Do: Configure date and time format tokens at the application level for consistency
- Do: Use FilterPipe with pure predicate functions to avoid unnecessary recalculations
- Do: Handle null/undefined values appropriately when using date/time pipes
- Don't: Use complex, impure functions with MapperPipe as they may cause performance issues
- Don't: Rely on 'short' or 'medium' formats with DateFormatPipe as noted in the implementation
- Don't: Assume FilterPipe will throw errors for non-array inputs - it returns empty arrays instead
- Don't: Forget to provide format tokens when using date/time pipes in different locales

Migration Notes:
- v1.0.0: Initial release - no migration needed
- These pipes replace manual data transformation logic in components
- When migrating from inline transformations, extract logic into pure functions for use with MapperPipe
- Date/time pipes provide centralized formatting configuration through tokens

Related Components / Patterns:
- KbmMapper and KbmMatcher types from @kebormed/x-core/types for function signatures
- Date and time formatting tokens from @kebormed/x-core/tokens for configuration
- Miscellaneous utilities from @kebormed/x-core/utils/miscellaneous for helper functions
- Angular's built-in pipes (DatePipe, AsyncPipe) for additional transformation needs
- Angular CDK utilities for robust type coercion and validation

Changelog:
- v1.0.0: Initial release with MapperPipe, FilterPipe, BooleanToValuePipe, DateFormatPipe, and TimeFormatPipe

-----------------------------------------------------------

## File: ./projects/core/utils/validation/validation.txt

Validation - Utility Documentation
Status: stable
Since: v1.0.0

Short description: A collection of validation utilities for handling asynchronous form validation with RxJS operators.

Purpose and Overview:
The Validation module provides utilities for handling asynchronous validation in Angular applications. It includes operators that help manage the complexity of async validation by providing debouncing, distinct value filtering, and proper observable handling. These utilities are particularly useful for form validation scenarios where you need to validate user input against remote services while maintaining good performance and user experience.

Quick Start:
  Import:
    import { asyncValidatorOperator } from '@kebormed/x-core/utils/validation';

  Minimal usage:
    // In a service or component
    const emailValidator = asyncValidatorOperator(this.emailService.validateEmail);

    // Apply to an observable stream
    valueChanges$.pipe(
      emailValidator
    ).subscribe(validationResult => {
      // Handle validation result
    });

Available Functions:

asyncValidatorOperator<T>(fn: (value: T) => Observable<ValidationErrors | null>)
  Description: Creates an async validator operator that applies debounce time and distinct value filtering to the source observable before passing the value to the provided async validation function. The operator handles asynchronous validation in reactive forms or similar scenarios.

  Parameters:
    - fn: The async validation function that returns an observable of validation errors or null

  Returns: An operator function that can be used in an observable chain to apply async validation

  Behavior:
    - Applies a debounce time of 300ms to delay emission of values
    - Ensures only distinct values are passed through, avoiding unnecessary validation calls
    - Executes the provided async validation function on each emitted value
    - Completes after the first emitted validation result

Usage Examples:

Basic Usage with Form Control:
  import { FormControl, Validators } from '@angular/forms';
  import { asyncValidatorOperator } from '@kebormed/x-core/utils/validation';

  // In a component or service
  const emailControl = new FormControl('', [
    Validators.required,
    asyncValidatorOperator(this.emailValidationService.validateEmail)
  ]);

Custom Validation Service Integration:
  import { Injectable } from '@angular/core';
  import { Observable, of } from 'rxjs';
  import { ValidationErrors } from '@angular/forms';
  import { asyncValidatorOperator } from '@kebormed/x-core/utils/validation';

  @Injectable({
    providedIn: 'root'
  })
  export class UserValidationService {

    validateUsername(username: string): Observable<ValidationErrors | null> {
      // Simulate API call
      return this.http.get(`/api/validate-username/${username}`)
        .pipe(
          map(response => response.isValid ? null : { usernameTaken: true })
        );
    }

    createUsernameValidator() {
      return asyncValidatorOperator(this.validateUsername.bind(this));
    }
  }

Reactive Form Integration:
  import { Component } from '@angular/core';
  import { FormBuilder, FormGroup } from '@angular/forms';
  import { asyncValidatorOperator } from '@kebormed/x-core/utils/validation';

  @Component({
    selector: 'app-user-form',
    template: `
      <form [formGroup]="userForm">
        <input formControlName="email" placeholder="Email">
        <div *ngIf="userForm.get('email')?.errors?.['emailTaken']">
          Email is already taken
        </div>
      </form>
    `
  })
  export class UserFormComponent {
    userForm: FormGroup;

    constructor(
      private fb: FormBuilder,
      private validationService: ValidationService
    ) {
      this.userForm = this.fb.group({
        email: ['', {
          validators: [Validators.required, Validators.email],
          asyncValidators: [asyncValidatorOperator(this.validationService.validateEmail)]
        }]
      });
    }
  }

Observable Stream Validation:
  import { Subject } from 'rxjs';
  import { asyncValidatorOperator } from '@kebormed/x-core/utils/validation';

  // Create a subject for user input
  const searchInput$ = new Subject<string>();

  // Apply async validation to the stream
  const validatedSearch$ = searchInput$.pipe(
    asyncValidatorOperator(this.searchValidationService.validateSearchTerm)
  );

  // Subscribe to validation results
  validatedSearch$.subscribe(validationResult => {
    if (validationResult) {
      console.log('Validation errors:', validationResult);
    } else {
      console.log('Search term is valid');
    }
  });

API Reference:
  Exports:
    export const asyncValidatorOperator: <T>(
      fn: (value: T) => Observable<ValidationErrors | null>
    ) => (source: Observable<T>) => Observable<ValidationErrors | null>

  Dependencies:
    - RxJS operators: debounceTime, distinctUntilChanged, first, switchMap
    - Angular Forms: ValidationErrors type

Best Practices and Gotchas:
- Do: Use asyncValidatorOperator for form controls that need server-side validation
- Do: Combine with synchronous validators for comprehensive validation
- Do: Handle loading states in your UI while async validation is in progress
- Do: Provide meaningful error messages for validation failures
- Don't: Use for simple client-side validation that doesn't require server interaction
- Don't: Forget to handle the debounce behavior in your UI (users may see delayed validation)
- Don't: Chain multiple asyncValidatorOperator calls without considering performance impact

Migration Notes:
This is the initial release of the validation utilities. Future versions may include additional validation operators and utilities.

Related Components / Patterns:
- Angular Reactive Forms - Primary use case for async validation
- RxJS Operators - Built on top of RxJS operator patterns
- Form Validation Services - Often used in conjunction with validation services
- Debounced Input Components - Complements components that handle user input with debouncing

Changelog:
- v1.0.0: Initial release with asyncValidatorOperator

-----------------------------------------------------------

## File: ./projects/kit/audit-log/audit-log-list/audit-log-list.txt

AuditLogListComponent - Component Documentation
Status: stable
Since: v1.0.0

Short description: A table component for displaying audit log entries with sortable columns and status formatting.

Purpose and Overview:
The AuditLogListComponent provides a structured way to display audit log entries in a tabular format. It extends the BaseTable abstract class to ensure consistent table behavior across the application. The component displays key audit information including timestamps, patient details, actions performed, status codes, and user information. It supports column sorting and provides visual status indicators through CSS classes. The component is designed to handle large datasets efficiently while maintaining a clean, accessible interface for reviewing system audit trails.

Quick Start:
  Import:
    import { AuditLogListComponent } from '@kebormed/x-kit/audit-log';

    @Component({
      imports: [AuditLogListComponent]
    })
    export class DemoComponent {}

  Minimal usage (HTML):
    <kbm-audit-log-list [data]="logEntries" (sort)="handleSort($event)"></kbm-audit-log-list>

Inputs and Outputs:
- data: input<BaseLogEntry[]> = []
  Description: Array of audit log entries to display in the table. Each entry should conform to the BaseLogEntry interface from @kebormed/x-kit/model.

- sort: output<SortEvt>()
  Description: Event emitted when a column header is clicked for sorting. Contains the field name and sort direction information.

Slots and Content Projection:
The component uses an action template slot through the kbm-table component's ActionTemplateDirective. This allows for custom action buttons or controls to be projected into the rightmost column of each row.

Styling and Theming:
- The component relies on global styles and inherited styles from the BaseTable class and kbm-table component
- Status codes are rendered with CSS classes following the pattern 'status-{statusCode}' (e.g., 'status-0', 'status-1', 'status-2')
- Patients without an ID display "N/A" with the 'no-patient' CSS class
- Responsive behavior is inherited from the underlying table component
- No component-specific SCSS variables are exposed

Accessibility:
- Keyboard: Full keyboard navigation support through the underlying table component, including tab navigation and sort activation via Enter/Space
- ARIA: Proper table semantics with sortable column headers, row/cell relationships maintained by the base table
- Color contrast: Status indicators should meet WCAG compliance requirements through appropriate CSS styling

Visual Examples:
Basic usage and variants:
  - Basic: Displays audit log entries in a sortable table format
  - Status variants:
    * Success (status code 0): Displays "Success" label
    * Warning (status code 1): Displays "Warning" label
    * Error (status code 2): Displays "Error" label
    * Unknown (any other code): Displays "Unknown" label
  - Patient display:
    * With patient: Shows "LastName, FirstName" format
    * Without patient: Shows "N/A" with special styling

Behaviors and Lifecycle:
The component extends BaseTable<BaseLogEntry> which provides consistent table behavior and lifecycle management. It uses OnPush change detection strategy for optimal performance. The getStatusLabel method provides real-time status code mapping without requiring additional data processing. Column sorting is handled through the inherited table functionality and emits sort events for external handling.

API Reference:
  Exports:
    export class AuditLogListComponent extends BaseTable<BaseLogEntry> {
      readonly data = input<BaseLogEntry[]>([]);
      readonly sort = output<SortEvt>();
      getStatusLabel(code: number): string;
    }

    // Related interfaces from @kebormed/x-kit/model
    export interface BaseLogEntry {
      id: ID;
      organizationId: ID;
      timestamp: number;
      patientId: ID;
      lastName: string;
      firstName: string;
      statusCode: number;
      action: string;
      username: string;
      userId: ID;
    }

Best Practices and Gotchas:
- Do: Use the component with proper BaseLogEntry data structure
- Do: Handle the sort event to implement server-side or client-side sorting
- Do: Provide appropriate CSS styles for status classes (status-0, status-1, status-2)
- Do: Use the action template for additional row-level actions when needed
- Don't: Modify the BaseLogEntry interface structure without updating the component
- Don't: Forget to handle loading states when fetching audit log data
- Don't: Override the getStatusLabel method without considering all possible status codes

Migration Notes:
- v1.0.0: Initial release using modern Angular signals (input/output functions)
- Component uses standalone architecture and OnPush change detection
- Extends BaseTable for consistent table behavior across the application

Related Components / Patterns:
- BaseTable: Abstract base class providing common table functionality
- TableModule: Core table components from @kebormed/x-core/components/table
- SortDirective: Provides sorting functionality from @kebormed/x-core/components/sort
- BaseLogEntry: Data model interface from @kebormed/x-kit/model
- Similar audit and logging components throughout the application

Changelog:
- v1.0.0: Initial release with sortable columns, status formatting, and patient display logic

-----------------------------------------------------------

## File: ./projects/kit/components/kit-components.txt

Kit Components - Component Documentation
Status: stable
Since: v1.0.0

Short description: A collection of specialized form input components for country selection and phone number entry with international formatting.

Purpose and Overview:
The Kit Components module provides two specialized form input components designed for international applications. The CountryInputComponent offers a dropdown selection for countries, while the PhoneInputComponent provides a sophisticated phone number input with country prefix selection and automatic formatting. Both components extend the CustomFieldControl base class from @kebormed/x-core, ensuring consistent form integration and validation support. These components are designed to work seamlessly with Angular's reactive forms and provide enhanced user experience for international data entry.

Quick Start:
  Import:
    import { CountryInputComponent } from '@kebormed/x-kit/components/country-input';
    import { PhoneInputComponent } from '@kebormed/x-kit/components/phone-input';

    // Or import both from the main components module
    import { CountryInputComponent, PhoneInputComponent } from '@kebormed/x-kit/components';

  Minimal usage (HTML):
    <!-- Country Input -->
    <kbm-country-input [(ngModel)]="selectedCountry"></kbm-country-input>

    <!-- Phone Input -->
    <kbm-phone-input [(ngModel)]="phoneNumber"></kbm-phone-input>

Components:

=== CountryInputComponent ===

Inputs and Outputs:
- @Input() filter: (country: CountryData) => boolean = () => true
  Description: A function to filter the list of countries displayed in the dropdown. Defaults to showing all countries.

- Inherits from CustomFieldControl<string>:
  - @Input() disabled: boolean - Disables the input
  - @Input() id: string - Sets the component ID
  - @Output() value changes through ControlValueAccessor interface

Slots and Content Projection:
No content projection supported. The component renders a select element with country options.

Styling and Theming:
- No component-specific styles (empty SCSS file)
- Relies on external styling or browser defaults
- Can be styled through global CSS targeting the select element
- Responsive behavior depends on parent container styling

Accessibility:
- Keyboard: Standard select element keyboard navigation (arrow keys, Enter, Escape)
- ARIA: Uses native select element ARIA support
- Color contrast: Inherits from browser defaults or global styles

Visual Examples:
Basic usage:
  <kbm-country-input [(ngModel)]="country"></kbm-country-input>

With filtering (show only specific countries):
  <kbm-country-input
    [(ngModel)]="country"
    [filter]="countryFilter">
  </kbm-country-input>

Behaviors and Lifecycle:
- Extends CustomFieldControl for form integration
- Uses OnPush change detection for performance
- Injects COUNTRIES_LIST token for country data
- Handles focus management and container clicks
- Automatically marks for check when value changes

API Reference:
  Exports:
    export class CountryInputComponent extends CustomFieldControl<string>

  Dependencies:
    - @kebormed/x-core/abstraction/field (CustomFieldControl, FieldControl)
    - @kebormed/x-core (COUNTRIES_LIST token)
    - @kebormed/x-core/utils/pipes (FilterPipe)
    - CountryData type from @kebormed/x-core

=== PhoneInputComponent ===

Inputs and Outputs:
- @Input() replacer: (value: string) => string = characterReplacer
  Description: Function to clean/format the phone number input. Default removes non-numeric characters.

- Inherits from CustomFieldControl<PhoneValue>:
  - @Input() disabled: boolean - Disables both prefix and number inputs
  - @Input() id: string - Sets the component ID
  - @Output() value changes through ControlValueAccessor interface

- PhoneValue type:
  {
    prefix: string | null;
    number: string | null;
  }

Slots and Content Projection:
No content projection supported. The component renders a select element for country prefix and an input element for the phone number.

Styling and Theming:
- SCSS variables: --kbm-input-border-color (used for dropdown arrow, defaults to #ccc)
- Uses flexbox layout with prefix selector and number input
- Custom dropdown arrow styling with CSS pseudo-element
- Responsive: Number input takes remaining flex space
- Composition: Works well within form layouts and field containers

Accessibility:
- Keyboard: Tab navigation between prefix and number fields, automatic focus management
- ARIA: Uses native form element ARIA support
- Color contrast: Dropdown arrow respects CSS variable theming
- Focus management: Automatically focuses number input after prefix selection

Visual Examples:
Basic usage:
  <kbm-phone-input [(ngModel)]="phoneNumber"></kbm-phone-input>

With custom replacer:
  <kbm-phone-input
    [(ngModel)]="phoneNumber"
    [replacer]="customReplacer">
  </kbm-phone-input>

Disabled state:
  <kbm-phone-input
    [(ngModel)]="phoneNumber"
    [disabled]="true">
  </kbm-phone-input>

Behaviors and Lifecycle:
- Extends CustomFieldControl for form integration
- Uses OnPush change detection for performance
- Parses incoming string values in format "(prefix)number"
- Automatically focuses number input after prefix selection
- Handles backspace to clear prefix when number is empty
- Input validation through replacer function
- Manages focus state across both input elements

API Reference:
  Exports:
    export class PhoneInputComponent extends CustomFieldControl<PhoneValue>
    export type PhoneValue = { prefix: string | null; number: string | null; }

  Dependencies:
    - @kebormed/x-core/abstraction/field (CustomFieldControl, FieldControl)
    - @kebormed/x-core/tokens (COUNTRIES_LIST)
    - @kebormed/x-core/types (CountryData, KbmNullable)
    - @kebormed/x-core/utils/dom (kbmInjectElement)
    - @kebormed/x-core (kbmIsEmpty, kbmIsPresent)

Best Practices and Gotchas:
- Do: Use these components with Angular reactive forms for best type safety
- Do: Provide appropriate validation for phone numbers using @kebormed/x-kit/validators if needed
- Do: Consider the PhoneValue structure when working with phone input values
- Don't: Assume phone input values are simple strings - they're objects with prefix and number properties
- Don't: Forget to handle the null states in PhoneValue properties
- Don't: Override the default replacer without understanding its impact on input validation

Migration Notes:
- v1.0.0: Initial release

Related Components / Patterns:
- Form components from @kebormed/x-core/components/form for complete form layouts
- Input components from @kebormed/x-core/components/input for consistent styling
- Validation patterns from @kebormed/x-kit/validators for form validation
- Model interfaces from @kebormed/x-kit/model for type definitions
- CustomFieldControl from @kebormed/x-core/abstraction/field for extending form controls

Changelog:
- v1.0.0: Initial release with CountryInputComponent and PhoneInputComponent

-----------------------------------------------------------

## File: ./projects/kit/device/device-form/device-form.txt

DeviceFormComponent - Component Documentation
Status: stable
Since: v1.0.0

Short description: A reactive form component for creating and editing device information with validation and data source integration.

Purpose and Overview:
The DeviceFormComponent provides a comprehensive form interface for managing device data within the application. It extends the BaseForm abstraction and implements BaseFormAction to provide consistent form behavior. The component handles both creation and editing modes, with automatic field disabling for certain properties during edit operations. It integrates with the validation system to ensure data integrity, particularly for unique serial numbers, and supports customizable action buttons through content projection.

Quick Start:
  Import:
    import { DeviceFormComponent } from '@kebormed/x-kit/device';

    @Component({
      imports: [DeviceFormComponent]
    })
    export class DemoComponent {}

  Minimal usage (HTML):
    <kbm-device-form [dataSources]="dataSources" (save)="onSave($event)"></kbm-device-form>

Inputs and Outputs:
- @Input() dataSources: BaseDataSource[] = []
  Description: Array of available data sources for the datasourceId dropdown selection. Each data source should have id and name properties.

- @Input() editData: BaseDevice | null
  Description: Device data to populate the form for editing. When provided, the component switches to edit mode and disables serialNumber and datasourceId fields.

- @Output() save: EventEmitter<BaseDevice>
  Description: Emitted when the form is submitted in create mode with valid data. Payload contains the complete device object.

- @Output() edit: EventEmitter<Partial<BaseDevice>>
  Description: Emitted when the form is submitted in edit mode with valid data. Payload contains the modified device properties.

Slots and Content Projection:
The component supports custom action buttons through content projection using the FormActionDirective:

```html
<kbm-device-form [dataSources]="dataSources">
  <ng-template kbmFormAction let-form>
    <button type="submit" [disabled]="!form.valid" kbm-button>Save Device</button>
    <button type="button" (click)="form.reset($event)" kbm-button>Cancel</button>
  </ng-template>
</kbm-device-form>
```

If no custom actions are provided, default Submit and Reset buttons are displayed.

Styling and Theming:
- The component uses flexbox layout with column direction and container queries support
- Inherits shared form styles from '../../_shared/form.scss'
- Host element has 'kbm-form' class applied automatically
- Form fields are organized in 'form-column' containers with data-for attributes for styling hooks
- Responsive behavior through container-type: inline-size

Accessibility:
- Keyboard: Standard form navigation with tab order through fields and buttons
- ARIA: Uses semantic form elements with proper labels and form controls
- Labels are properly associated with their corresponding input fields using kbm-label directive
- Form validation errors are communicated through Angular's form validation system

Visual Examples:
Basic usage and variants:
  - Create Mode:
    ```html
    <kbm-device-form
      [dataSources]="availableDataSources"
      (save)="createDevice($event)">
    </kbm-device-form>
    ```

  - Edit Mode:
    ```html
    <kbm-device-form
      [dataSources]="availableDataSources"
      [editData]="selectedDevice"
      (edit)="updateDevice($event)">
    </kbm-device-form>
    ```

  - With Custom Actions:
    ```html
    <kbm-device-form [dataSources]="dataSources">
      <ng-template kbmFormAction let-deviceForm>
        <button type="submit" [disabled]="!deviceForm.valid" kbm-button="primary">
          {{ deviceForm.isEdit ? 'Update' : 'Create' }} Device
        </button>
        <button type="button" (click)="cancel()" kbm-button="secondary">Cancel</button>
      </ng-template>
    </kbm-device-form>
    ```

Behaviors and Lifecycle:
- Form automatically switches between create and edit modes based on editData input
- In edit mode, serialNumber and datasourceId fields are disabled to prevent modification
- Async validation for serialNumber uniqueness only runs when the control is dirty
- Form submission is handled through host listeners for both submit and reset events
- Previous values are stored for reset functionality in edit mode
- Uses OnPush change detection strategy for optimal performance

API Reference:
  Exports:
    export class DeviceFormComponent extends BaseForm<BaseDevice> implements BaseFormAction {
      form: FormGroup<{
        datasourceId: FormControl<number | null>;
        name: FormControl<string | null>;
        serialNumber: FormControl<string | null>;
        softwareVersion: FormControl<string | null>;
      }>;

      dataSources: BaseDataSource[];
      editData: BaseDevice | null;
      save: OutputEmitterRef<BaseDevice>;
      edit: OutputEmitterRef<Partial<BaseDevice>>;

      submit(): void;
      reset(event: MouseEvent): void;
    }

Form Fields:
- datasourceId: Required, populated from dataSources input
- name: Required text field for device name
- serialNumber: Required text field with uniqueSerialNumber async validator
- softwareVersion: Required text field for software version

Validation:
- All fields are required using Angular's Validators.required
- serialNumber uses uniqueSerialNumber() async validator from @kebormed/x-kit/validators
- Form validation state is available through the inherited BaseForm functionality

Best Practices and Gotchas:
- Do: Provide a complete dataSources array with id and name properties
- Do: Handle both save and edit events appropriately in parent components
- Do: Use the component's isEdit property in custom action templates to show appropriate button text
- Don't: Modify editData after initial assignment; create a new object reference instead
- Don't: Submit the form while async validation is in progress
- Don't: Forget to handle loading states during form submission

Migration Notes:
- v1.0.0: Initial release with modern Angular standalone component architecture
- Uses signal-based outputs (output()) instead of @Output() decorators
- Implements modern control flow (@if, @for) in templates
- Extends BaseForm for consistent form behavior across the application

Related Components / Patterns:
- BaseForm: Abstract base class providing common form functionality
- BaseFormAction: Interface for standardized form action behavior
- FormActionDirective: Directive for custom action button templates
- InputGroupComponent, InputDirective, LabelDirective: Core input components
- ButtonComponent: Core button component for form actions
- ValidationService: Backend validation service used by uniqueSerialNumber validator

Changelog:
- v1.0.0: Initial release with create/edit functionality, validation, and content projection support

-----------------------------------------------------------

## File: ./projects/kit/device/device-list/device-list.txt

DeviceListComponent - Component Documentation
Status: stable
Since: v1.0.0

Short description: A table component that displays a list of devices with sortable columns and customizable actions.

Purpose and Overview:
The DeviceListComponent provides a standardized way to display device information in a tabular format. It extends the BaseTable component to offer sorting capabilities and action templates. The component is designed to handle BaseDevice objects and provides a consistent interface for displaying device data including name, datasource ID, state, software version, and timestamps. It leverages the core table infrastructure while providing device-specific column configurations and date formatting.

Quick Start:
  Import:
    import { DeviceListComponent } from '@kebormed/x-kit/device';

    @Component({
      selector: 'app-demo',
      imports: [DeviceListComponent]
    })
    export class DemoComponent {}

  Minimal usage (HTML):
    <kbm-device-list [data]="devices" (sort)="handleSort($event)"></kbm-device-list>

Inputs and Outputs:
- @Input() data: BaseDevice[] = []
  Description: Array of device objects to display in the table. Each device should conform to the BaseDevice interface from @kebormed/x-kit/model.

- @Output() sort: EventEmitter<SortEvt>
  Description: Emitted when a column header is clicked for sorting. The event contains sorting information including field name and direction.

Slots and Content Projection:
The component supports action templates through the ActionTemplateDirective. Custom actions can be provided by passing an action template reference:
- Action column: Supports custom action buttons/links through template projection
- All columns are sortable by default using the kbmColumnSort directive

Styling and Theming:
- No custom SCSS styles - inherits all styling from the base TableModule
- Responsive behavior depends on the underlying kbm-table component
- Date columns are formatted using Angular's DatePipe with 'dd/MM/yyyy' format
- Follows the standard table theming from @kebormed/x-core/components/table

Accessibility:
- Keyboard: Inherits keyboard navigation from the base table component
- ARIA: Table structure provides proper roles and relationships through the underlying TableModule
- Sorting: Column headers are keyboard accessible and announce sort state changes

Visual Examples:
Basic usage and variants:
  - Basic table with device data
  - Sortable columns (Name, Datasource Id, State, Software Version, Created At, Updated At)
  - Action column for custom operations
  - Date formatting for timestamp columns

Behaviors and Lifecycle:
- Extends BaseTable<BaseDevice> for consistent table behavior
- Uses OnPush change detection strategy for optimal performance
- Sorting events are passed through to parent components
- Date columns use custom templates with Angular DatePipe for consistent formatting
- Action column uses template projection for flexible action implementations

API Reference:
  Exports:
    export class DeviceListComponent extends BaseTable<BaseDevice>

  Dependencies:
    - BaseDevice interface from @kebormed/x-kit/model
    - BaseTable, TableModule, ColumnSortDirective, ActionTemplateDirective from @kebormed/x-core/components/table
    - SortDirective, SortEvt from @kebormed/x-core/components/sort
    - CommonModule from @angular/common

  Template Structure:
    - kbm-table wrapper with data binding and sort event handling
    - kbm-column definitions for each device property
    - Custom templates for date formatting (createdAt, updatedAt)
    - Action column with template projection support

Best Practices and Gotchas:
- Do: Provide BaseDevice[] data that conforms to the expected interface
- Do: Handle the sort event to implement server-side or client-side sorting
- Do: Use the action template for device-specific operations
- Don't: Modify the component's internal column structure directly
- Don't: Forget to handle loading states when data is being fetched
- Don't: Pass invalid date values as they may cause formatting issues

Migration Notes:
- v1.0.0: Initial release - no migration needed

Related Components / Patterns:
- BaseTable component from @kebormed/x-core/components/table
- BaseDevice interface from @kebormed/x-kit/model
- Other list components in the kit library (user-list, group-list, etc.)
- TableModule and related table directives from the core library

Changelog:
- v1.0.0: Initial release with basic device listing functionality

-----------------------------------------------------------

## File: ./projects/kit/group/group-form/group-form.txt

GroupFormComponent - Component Documentation
Status: stable
Since: v1.0.0

Short description: A reactive form component for creating and editing groups with validation and async uniqueness checking.

Purpose and Overview:
The GroupFormComponent provides a standardized form interface for creating and editing groups within the application. It extends the BaseForm class to provide consistent form behavior and integrates seamlessly with the application's design system. The component handles form validation including asynchronous validation for unique group names, manages form state for both creation and editing workflows, and supports content projection for custom form actions. It uses modern Angular patterns including standalone components, signals-based outputs, and the new control flow syntax.

Quick Start:
  Import:
    import { GroupFormComponent } from '@kebormed/x-kit/group';
    @Component({
      imports: [GroupFormComponent]
    })
    export class DemoComponent {}

  Minimal usage (HTML):
    <kbm-group-form (save)="onSaveGroup($event)"></kbm-group-form>

Inputs and Outputs:
- @Input() editData: BaseGroup | null = null
  Description: Sets the form to edit mode and populates the form with the provided group data. When provided, the form switches to edit mode and pre-fills the fields with existing data.

- save: OutputEmitterRef<BaseGroup>
  Description: Emitted when the form is submitted in create mode with the complete form values as BaseGroup. Uses modern output() function instead of @Output() decorator.

- edit: OutputEmitterRef<Partial<BaseGroup>>
  Description: Emitted when the form is submitted in edit mode with the form values as partial BaseGroup data. Uses modern output() function instead of @Output() decorator.

Slots and Content Projection:
The component supports content projection for custom form actions through the FormActionDirective:
- <ng-template kbmFormAction let-form>: Allows customizing the form action buttons. The template context provides access to the form instance ($implicit: GroupFormComponent).

Styling and Theming:
- Uses shared form styling (../../_shared/form.scss) that provides responsive grid layout
- The form layout is responsive and adjusts based on container width:
  * Large containers: 3 columns (default)
  * Medium containers (max-width: 768px): 2 columns
  * Small containers (max-width: 540px): 1 column
- CSS custom properties for customization:
  * --form-layout-cols-lg: Number of columns for large containers (default: 3)
  * --form-layout-cols-md: Number of columns for medium containers (default: 2)
  * --form-layout-cols-sm: Number of columns for small containers (default: 1)
  * --gap: Spacing between form elements (default: 16px)
- Host class binding: [class.kbm-form]="true" for consistent styling

Accessibility:
- Keyboard: Form controls are natively keyboard accessible with proper tab order following visual layout
- ARIA: The form element has role="form" for proper semantic structure and screen reader support
- Color contrast: Inherits WCAG compliant color contrast from the design system
- Labels: All form controls have associated kbm-label elements for proper screen reader support

Visual Examples:
Basic usage and variants:
  - Basic Create Mode:
    <kbm-group-form (save)="onSaveGroup($event)"></kbm-group-form>

  - Edit Mode:
    <kbm-group-form [editData]="groupToEdit" (edit)="onEditGroup($event)"></kbm-group-form>

  - With Custom Actions:
    <kbm-group-form (save)="onSaveGroup($event)">
      <ng-template kbmFormAction let-form>
        <button type="submit" [disabled]="!form.valid" kbm-button>Save Group</button>
        <button type="button" (click)="form.reset($event)" kbm-button>Cancel</button>
      </ng-template>
    </kbm-group-form>

  - States:
    * Create Mode: Default state with empty form fields and Submit/Reset buttons
    * Edit Mode: Pre-populated form fields with existing group data
    * Validation Errors: Form shows validation errors for required fields and unique name validation
    * Loading: During async validation, the form indicates loading state

Behaviors and Lifecycle:
The component extends BaseForm<BaseGroup> and implements BaseFormAction interface to inherit common form functionality. Form validation includes:
- Name field: Required, max length 32 characters, and uniqueGroupName() async validator
- Description field: Required, max length 32 characters
Uses modern Angular patterns including OnPush change detection strategy, standalone component architecture, and modern control flow (@if/@else) in templates. The form handles both create and edit modes automatically based on editData input. Host listeners manage form submission and reset functionality. The _previousValue property stores initial form state for reset operations.

API Reference:
  Exports:
    export class GroupFormComponent extends BaseForm<BaseGroup> implements BaseFormAction

    Properties:
    - form: FormGroup with name and description controls
    - _previousValue: Partial<BaseGroup> - stores previous form values for reset
    - save: OutputEmitterRef<BaseGroup> - emitted on create mode submission
    - edit: OutputEmitterRef<Partial<BaseGroup>> - emitted on edit mode submission

    Inputs:
    - editData: BaseGroup | null - sets form in edit mode with provided data

    Content Child:
    - actionTemplate: FormActionDirective<{ $implicit: GroupFormComponent }> - custom actions template

    Methods:
    - submit(): void - handles form submission via @HostListener('submit')
    - reset(event: Event): void - resets form to previous state via @HostListener('reset')

    Inherited from BaseForm:
    - valid: boolean - returns form validity status
    - value: Partial<BaseGroup> - returns current form values
    - isEdit: boolean - indicates if form is in edit mode
    - id: string - unique form identifier

Best Practices and Gotchas:
- Do: Use the editData input for editing existing groups
- Do: Handle both save and edit outputs in the parent component
- Do: Use the kbmFormAction directive for custom form actions when needed
- Do: Check form validity before processing submission events
- Don't: Modify form controls directly; use the provided inputs and outputs
- Don't: Forget to handle loading states during async validation
- Don't: Submit the form while async validators are still processing

Migration Notes:
- v1.1.0: Updated to use modern output() function instead of @Output() decorator
- v1.0.0: Initial release with traditional @Output() decorators

Related Components / Patterns:
- BaseForm from @kebormed/x-core/abstraction/form - Base class providing common form functionality
- BaseGroup from @kebormed/x-kit/model - Data model interface for groups
- uniqueGroupName from @kebormed/x-kit/validators - Async validator for unique group names
- FormActionDirective from @kebormed/x-core/components/form - Directive for custom form actions
- InputGroupComponent, InputDirective, LabelDirective from @kebormed/x-core/components/input - Form input components
- ButtonComponent from @kebormed/x-core/components/button - Button component for form actions

Changelog:
- v1.1.0: Updated documentation to reflect modern Angular patterns, corrected outputs to use output() function, added detailed validator specifications, documented BaseFormAction interface implementation, enhanced API reference with inherited methods
- v1.0.0: Initial release

-----------------------------------------------------------

## File: ./projects/kit/group/group-member-list/group-member-list.txt

GroupMemberListComponent - Component Documentation
Status: stable
Since: v1.0.0

Short description: A table component for displaying and managing group members with sortable columns and customizable actions.

Purpose and Overview:
The GroupMemberListComponent provides a tabular view of group members, displaying their personal information and roles within a group. It extends the BaseTable component to provide sorting functionality and custom rendering of user types through the USER_TYPES token. This component is designed to be used in group management interfaces where administrators need to view and manage group members efficiently. The component leverages Angular's modern standalone architecture and follows OnPush change detection strategy for optimal performance.

Quick Start:
  Import:
    import { GroupMemberListComponent } from '@kebormed/x-kit/group';
    import { BaseGroupMember } from '@kebormed/x-kit/model';
    import { SortEvt } from '@kebormed/x-core/components/sort';

  Minimal usage (HTML):
    <kbm-group-member-list [data]="groupMembers" (sort)="handleSort($event)">
      <ng-template #actionTemplate let-member>
        <button (click)="editMember(member)">Edit</button>
        <button (click)="removeMember(member)">Remove</button>
      </ng-template>
    </kbm-group-member-list>

Inputs and Outputs:
- @Input() data: BaseGroupMember[] = []
  Description: Array of group members to display in the table. Each member should contain properties like firstName, lastName, userName, email, userType, organizationUserId, and creationTime.

- @Output() sort: EventEmitter<SortEvt>
  Description: Emitted when a column sort is triggered. The event contains sorting information including field name and direction for implementing server-side or client-side sorting.

Slots and Content Projection:
The component uses the kbm-table component's content projection capabilities:
- actionTemplate: Template reference for the action column that receives the group member as context through the let-member syntax. This allows for customizable actions like edit, remove, or view details.

Styling and Theming:
- The component inherits all styling from the base kbm-table component
- No custom SCSS variables or CSS custom properties are exposed at the component level
- Responsive behavior follows the base table component's responsive design patterns
- The component relies on the table module's built-in styling for consistent appearance

Accessibility:
- Keyboard: Inherits keyboard navigation from the BaseTable component, supporting tab navigation and arrow key movement
- ARIA: Uses appropriate ARIA roles and attributes from the base table component including table, columnheader, and cell roles
- Color contrast: Follows the base table's color contrast guidelines ensuring WCAG compliance

Visual Examples:
Basic usage and variants:
  - Basic Group Member List:
    Displays a table with columns for First Name, Last Name, Username, Email, Role (mapped user type), and Actions
    All columns except Actions are sortable with visual sort indicators

  - With Custom Actions:
    The action column can be customized through the actionTemplate to include buttons for edit, remove, view details, or other member-specific operations

  - Empty State:
    When no data is provided, the table displays an appropriate empty state inherited from the base table component

Behaviors and Lifecycle:
The component extends BaseTable<BaseGroupMember> to inherit table functionality including:
- Sorting capabilities through the ColumnSortDirective
- Action template context creation through the actionContext method
- User type mapping through the mapUserType method that converts numeric UserType values to their string key representations
- Dependency injection of USER_TYPES token for user type display names
- OnPush change detection strategy for optimal performance

API Reference:
  Exports:
    export class GroupMemberListComponent extends BaseTable<BaseGroupMember> {
      @Input() data: BaseGroupMember[] = [];
      @Output() sort = new EventEmitter<SortEvt>();

      userTypes = inject(USER_TYPES);

      actionContext(data: unknown): ContextWithImplicit<BaseGroupMember>;
      mapUserType(value: UserType): UserTypeKey;
    }

    Dependencies:
    - BaseGroupMember from '@kebormed/x-kit/model'
    - UserType, UserTypeKey from '@kebormed/x-kit/model'
    - SortEvt from '@kebormed/x-core/components/sort'
    - USER_TYPES from '@kebormed/x-kit/tokens'
    - BaseTable from '@kebormed/x-core/components/table'

Best Practices and Gotchas:
- Do: Provide an actionTemplate to enable user interactions with group members
- Do: Handle the sort event to implement proper sorting logic (server-side or client-side)
- Do: Ensure the data array contains valid BaseGroupMember objects with all required properties
- Do: Provide the USER_TYPES token in your application's dependency injection configuration
- Don't: Modify the component's internal column structure or table configuration
- Don't: Forget to import the necessary types from the model and core modules
- Don't: Assume the component will handle data loading or error states - these should be managed by the parent component

Migration Notes:
Not applicable as this is the initial version of the component.

Related Components / Patterns:
- BaseTable from '@kebormed/x-core/components/table' - The foundational table component
- TableModule from '@kebormed/x-core/components/table' - Provides table functionality and directives
- Group management components that display and manage group membership
- User management interfaces that show user information in tabular format
- Components utilizing the USER_TYPES token for user type display
- SortDirective and ColumnSortDirective for sorting functionality

Changelog:
- v1.0.0: Initial release with basic group member display and sorting capabilities

-----------------------------------------------------------

## File: ./projects/kit/hcp/hcp-form/hcp-form.txt

HcpFormComponent - Component Documentation
Status: stable
Since: v1.0.0

Short description: A comprehensive reactive form component for creating and editing healthcare professional (HCP) information with validation and flexible action templates.

Purpose and Overview:
The HCP Form component provides a standardized, type-safe form for collecting and managing healthcare professional information. It handles both creation of new HCP records and editing of existing ones, with comprehensive validation for all fields including async validation for unique email and username. The component extends BaseForm<BaseHCP> and implements BaseFormAction, providing a consistent form interface. It includes fields for personal information (firstName, lastName), contact details (email, phone), account information (username, userType), professional details (speciality, practice), address data, and active status management. The component uses modern Angular patterns including signals for inputs/outputs, standalone architecture, and OnPush change detection for optimal performance.

Quick Start:
  Import:
    import { HcpFormComponent } from '@kebormed/x-kit/hcp/hcp-form';
    import { CommonModule } from '@angular/common';
    import { ReactiveFormsModule } from '@angular/forms';

    @Component({
      selector: 'app-hcp-management',
      standalone: true,
      imports: [
        CommonModule,
        ReactiveFormsModule,
        HcpFormComponent
      ]
    })
    export class HcpManagementComponent {}

  Minimal usage (HTML):
    <kbm-hcp-form
      [editData]="hcpToEdit"
      [allowUserTypes]="allowedUserTypes"
      (save)="onSaveHcp($event)"
      (edit)="onEditHcp($event)">
    </kbm-hcp-form>

Inputs and Outputs:
- @Input() editData: BaseHCP | null = null
  Description: Sets the form data for editing an existing HCP. When provided, the form enters edit mode, disabling certain fields like username, email, and userType to prevent changing critical identification information.

- allowUserTypes: InputSignal<number[]> = input<number[]>([])
  Description: Signal input that sets the allowed user types to be displayed in the user type dropdown. Empty array shows all available user types from the USER_TYPES token.

- save: OutputEmitterRef<BaseHCP>
  Description: Emitted when a new HCP form is submitted and valid. Contains the complete HCP data with all form field values.

- edit: OutputEmitterRef<Partial<BaseHCP>>
  Description: Emitted when an existing HCP form is submitted and valid. Contains the updated HCP data that differs from the original values.

Slots and Content Projection:
The component supports content projection for custom form actions using the FormActionDirective:

<kbm-hcp-form>
  <ng-template kbmFormAction let-form>
    <button type="submit" [disabled]="!form.valid" kbm-button>Custom Submit</button>
    <button type="button" (click)="form.reset($event)" kbm-button>Custom Reset</button>
  </ng-template>
</kbm-hcp-form>

When no custom actions are provided, default Submit and Reset buttons are displayed.

Styling and Theming:
- Uses responsive grid layout that adapts to different screen sizes through CSS container queries
- Host element is configured as a flex column container with container-type: inline-size
- Inherits shared form styles from '../../_shared/form.scss' for consistent form appearance
- Form fields are organized in .form-column containers with data-for attributes for styling hooks
- Uses standard input components from @kebormed/x-core/components/input for consistent theming
- Responsive behavior: Automatically adjusts layout based on container size using CSS container queries

Accessibility:
- Keyboard: All form fields are tabbable in logical order (personal info → contact → account → professional → address → status → actions). Submit and reset buttons are keyboard accessible with Enter and Space keys.
- ARIA: Form fields use semantic HTML form elements with proper label associations via kbm-label components. Radio group for active status uses kbm-radio-group with proper ARIA roles.
- Color contrast: Relies on underlying input components which follow WCAG 2.1 AA guidelines for color contrast ratios.

Visual Examples:
Basic usage and variants:
  - Basic: Clean form layout with all HCP fields organized in responsive columns
  - Edit Mode: Same layout but with username, email, and userType fields disabled to prevent modification of critical data
  - Custom Actions: Form with custom action buttons replacing default Submit/Reset buttons
  - Filtered User Types: User type dropdown showing only allowed user types based on allowUserTypes input

Behaviors and Lifecycle:
The component extends BaseForm<BaseHCP> and implements BaseFormAction interface. Form validation includes required field validation for firstName, lastName, email, username, and userType; email format validation; async validation for unique email and username using uniqueEmail() and uniqueUsername() validators from @kebormed/x-kit/validators; maximum length validation (32 chars for names/username, 24 for phone). In edit mode, userType, username, and email fields are automatically disabled. The form maintains previous values for reset functionality and uses OnPush change detection strategy for optimal performance. Host listeners handle form submission and reset events, emitting appropriate save or edit events based on the current mode.

API Reference:
  Exports:
    export class HcpFormComponent extends BaseForm<BaseHCP> implements BaseFormAction {
      // Form instance
      form: FormGroup<{
        firstName: FormControl<string | null>;
        lastName: FormControl<string | null>;
        email: FormControl<string | null>;
        phone: FormControl<string | null>;
        username: FormControl<string | null>;
        userType: FormControl<number | null>;
        speciality: FormControl<string | null>;
        practice: FormControl<string | null>;
        address: FormControl<string | null>;
        address1: FormControl<string | null>;
        city: FormControl<string | null>;
        state: FormControl<string | null>;
        postalCode: FormControl<string | null>;
        countryCode: FormControl<string | null>;
        isActive: FormControl<boolean>;
      }>;

      // Inputs
      @Input() editData: BaseHCP | null;
      allowUserTypes: InputSignal<number[]>;

      // Outputs
      save: OutputEmitterRef<BaseHCP>;
      edit: OutputEmitterRef<Partial<BaseHCP>>;

      // Content projection
      @ContentChild(FormActionDirective, {static: true})
      actionTemplate: FormActionDirective<{ $implicit: HcpFormComponent }>;

      // Protected properties
      protected userTypes: IUserType; // Injected from USER_TYPES token

      // Methods
      submit(): void; // Handles form submission
      reset(event: Event): void; // Resets form to previous values
      userTypeFilter(item: KeyValue<string, UserType>, test: UserType[]): boolean; // Filters user types
    }

Best Practices and Gotchas:
- Do: Use the allowUserTypes input to restrict which user types are available in the dropdown based on your application's business rules
- Do: Provide custom form actions using the FormActionDirective when you need specialized button behavior or additional actions
- Do: Handle both save and edit outputs for complete form functionality - save for new records, edit for updates
- Do: Implement proper error handling for async validation states in your parent component
- Don't: Attempt to modify the userType, username, or email fields when the form is in edit mode - these are automatically disabled
- Don't: Forget to import the required dependencies (BaseHCP from @kebormed/x-kit/model, validators from @kebormed/x-kit/validators)
- Don't: Override the form's built-in validation without understanding the business requirements for HCP data integrity

Migration Notes:
Not applicable - this is the initial stable version of the component.

Related Components / Patterns:
- @kebormed/x-kit/model - Provides the BaseHCP interface and UserType definitions used for type safety
- @kebormed/x-kit/validators - Provides uniqueEmail() and uniqueUsername() async validators for data integrity
- @kebormed/x-kit/tokens - Provides USER_TYPES injection token for user type data
- @kebormed/x-kit/hcp/hcp-list - Companion component for displaying lists of healthcare professionals
- @kebormed/x-core/components/input - Underlying input components used throughout the form
- @kebormed/x-kit/components/phone-input - Specialized phone number input component
- @kebormed/x-kit/components/country-input - Country selection component for address information
- @kebormed/x-core/abstraction/form - BaseForm class that provides common form functionality

Changelog:
- v1.1.0: Updated to use modern Angular signals for inputs/outputs, improved type safety
- v1.0.0: Initial release with comprehensive HCP form functionality

-----------------------------------------------------------

## File: ./projects/kit/hcp/hcp-list/hcp-list.txt

---
title: HcpList
status: stable
since: v1.0.0
---

# `HcpListComponent` - Component Documentation

**Status:** stable
**Since:** v1.0.0

**Short description:** A responsive table/accordion component for displaying Healthcare Professional (HCP) data with sorting capabilities and action templates.

## Purpose and Overview

The HcpListComponent solves the problem of displaying Healthcare Professional data in a user-friendly, responsive format. It provides a dual-view approach: a sortable table for larger screens and an accordion layout for mobile devices. The component extends the BaseTable class to inherit common table functionality while adding HCP-specific features like user type mapping and responsive design. Key responsibilities include data presentation, sorting management, and responsive layout switching based on screen size.

## Quick Start

### Import:
```ts
import { HcpListComponent } from '@kebormed/x-kit/hcp';

@Component({
  selector: 'app-demo',
  imports: [HcpListComponent],
  template: `<kbm-hcp-list [data]="hcpData" (sort)="onSort($event)"></kbm-hcp-list>`
})
export class DemoComponent {}
```

### Minimal usage (HTML):
```html
<kbm-hcp-list [data]="hcpUsers" (sort)="handleSort($event)"></kbm-hcp-list>
```

## Inputs and Outputs

### Inputs:
- **@Input() data: BaseUser[] = []**
  Description: Array of user data to display in the list. Should contain BaseUser objects with HCP-specific properties. Defaults to empty array.

### Outputs:
- **@Output() sort: EventEmitter<SortEvt>**
  Description: Emitted when user clicks on sortable column headers. Payload contains sorting information including field name and direction.

## Slots and Content Projection

The component supports action templates through the `actionTemplate` template reference:

```html
<kbm-hcp-list [data]="hcpData" (sort)="onSort($event)">
  <ng-template #actionTemplate let-user>
    <button (click)="editUser(user)">Edit</button>
    <button (click)="deleteUser(user)">Delete</button>
  </ng-template>
</kbm-hcp-list>
```

The action template receives the user data as an implicit context variable.

## Styling and Theming

- **SCSS variables:** Component uses empty stylesheet, relying on inherited styles from BaseTable and imported components
- **Composition tips:** Wrap in `<kbm-card>` for elevation and consistent spacing
- **Responsive behavior:** Automatically switches between table (desktop) and accordion (mobile) layouts based on screen size breakpoints provided by `isSmallScreen$` service

## Accessibility

- **Keyboard:** Full keyboard navigation support inherited from BaseTable and KbmAccordion components
- **ARIA:** Proper ARIA roles and relationships provided by underlying table and accordion components
- **Color contrast:** Inherits WCAG compliance from the design system components

## Visual Examples

### Basic usage and variants:

**Desktop View (Table):**
- Displays data in sortable columns: First Name, Last Name, Username, Email, Role, Active Status, Last Login
- Each column header is clickable for sorting
- Action column for custom operations

**Mobile View (Accordion):**
- Displays data in collapsible accordion items
- Each item shows the user's first name as the title
- Action templates are rendered within each accordion item

**States:**
- Loading state handled by parent component
- Empty state shows empty table/accordion
- Error states managed through data binding

## Behaviors and Lifecycle

The component leverages Angular's OnPush change detection strategy for optimal performance. It uses the `isSmallScreen$` observable to reactively switch between desktop and mobile layouts. The `mapUserType` method transforms numeric user type values to readable strings using the injected USER_TYPES token. The component extends BaseTable<BaseHCP> to inherit common table functionality while providing HCP-specific implementations.

## API Reference

### Exports:
```ts
export class HcpListComponent extends BaseTable<BaseHCP> {
  @Input() data: BaseUser[] = [];
  @Output() sort = new EventEmitter<SortEvt>();

  isSmallScreen$ = isSmallScreen$();
  userTypes = inject(USER_TYPES);

  actionContext(data: unknown): ContextWithImplicit<BaseHCP>;
  mapUserType(value: UserType): UserTypeKey;
}
```

### Dependencies:
- **Models:** `BaseHCP`, `BaseUser`, `UserType`, `UserTypeKey` from `@kebormed/x-kit/model`
- **Components:** `KbmAccordion`, `BaseTable`, `TableModule` from `@kebormed/x-core/components`
- **Services:** `isSmallScreen$` from `@kebormed/x-kit/services`
- **Tokens:** `USER_TYPES` from `@kebormed/x-kit/tokens`
- **Pipes:** `AsyncPipe`, `MapperPipe`, `DateFormatPipe`, `BooleanToValuePipe`

## Best Practices and Gotchas

### Do:
- ✔️ Provide BaseUser array with complete user information for proper display
- ✔️ Handle sort events to update data ordering
- ✔️ Use action templates for custom operations on user data
- ✔️ Ensure USER_TYPES token is properly provided in your application
- ✔️ Test responsive behavior on different screen sizes

### Don't:
- ❌ Mutate the data array directly; use immutable updates for sorting
- ❌ Forget to handle loading and error states in parent components
- ❌ Assume all BaseUser properties are available; check for optional fields
- ❌ Override the component's responsive behavior without considering UX impact

## Migration Notes

- v1.0.0: Initial release - No migration needed

## Related Components / Patterns

- **BaseTable:** Parent class providing common table functionality
- **KbmAccordion:** Used for mobile responsive layout
- **User management components:** Components that create, edit, or manage HCP data
- **BaseUser/BaseHCP models:** Data structures from `@kebormed/x-kit/model`
- **USER_TYPES token:** Dependency injection token from `@kebormed/x-kit/tokens`
- **Responsive services:** `isSmallScreen$` service for layout switching

## Changelog

| Version | Changes |
|---------|---------|
| 1.0.0   | Initial release with responsive table/accordion layout, sorting, and action template support |

-----------------------------------------------------------

## File: ./projects/kit/model/model.txt

Model - Component Documentation
Status: stable
Since: v1.0.0

Short description: A comprehensive collection of TypeScript interfaces and types that define data structures for users, tenants, groups, devices, data sources, audit logs, and API queries used throughout the application.

Purpose and Overview:
The Model module provides a centralized set of TypeScript interfaces and types that define the data structures used throughout the application. These models ensure consistency in data handling across components and services while providing strong typing for improved development experience and code quality. The module includes user management models (BaseUser, BasePatient, BaseHCP), organizational models (BaseTenant, BaseGroup), device management models (BaseDevice, BaseDeviceAssoc), data source models for parameter configuration, audit logging models, and API query models for standardized request parameters. By centralizing these definitions, the module promotes type safety, reduces code duplication, and provides a single source of truth for data structures.

Quick Start:
  Import:
    import { BaseUser, BaseTenant, BaseGroup, BaseApiQuery } from '@kebormed/x-kit/model';

  Minimal usage (TypeScript):
    // Define a user object with type safety
    const user: BaseUser = {
      id: 123,
      firstName: 'John',
      lastName: 'Doe',
      username: 'johndoe',
      email: 'john.doe@example.com',
      phone: '123-456-7890',
      isActive: true,
      lastLoginTime: Date.now(),
      isPendingActivation: false,
      isLocked: false,
      userType: 5, // Physician
      createdAt: Date.now()
    };

    // Create a query for API requests
    const apiQuery: BaseApiQuery = {
      q: 'search term',
      Page: 1,
      PageSize: 10,
      OrderBy: 'createdAt',
      Direction: 'desc'
    };

Inputs and Outputs:
N/A - This module exports TypeScript interfaces and types, not Angular components with inputs/outputs.

Slots and Content Projection:
N/A - This module provides TypeScript type definitions, not Angular components with content projection.

Styling and Theming:
N/A - This module provides TypeScript type definitions without visual components.

Accessibility:
N/A - This module provides TypeScript type definitions without UI elements.

Visual Examples:
N/A - This module provides TypeScript type definitions without visual representation.

Behaviors and Lifecycle:
The model interfaces define the structure of data objects used throughout the application lifecycle. These models are typically used in:
- API request/response handling
- Form validation and data binding
- State management and data storage
- Component property typing
- Service method parameters and return types

The models support inheritance patterns (BasePatient and BaseHCP extend BaseUser) and composition patterns (BaseTenant includes optional BaseUser admin, BaseGroupMember uses Pick utility type). The AsQueryParams<T> utility type enables conversion of typed objects to string-based query parameters for HTTP requests.

API Reference:
  Exports:
    // User Models
    export interface BaseUser { id: ID; firstName: string; lastName: string; username: string; email: string; phone: string; isActive: boolean; lastLoginTime: number; isPendingActivation: boolean; isLocked: boolean; userType: UserType; createdAt: number; }
    export interface BasePatient extends BaseUser { patientId: string; address: string; address1: string; city: string; state: string; postalCode: string; birthdate: string; countryCode: string; gender: string; height: number; weight: number; }
    export interface BaseHCP extends BaseUser { address: string; address1: string; city: string; state: string; postalCode: string; countryCode: string; practice: string; speciality: string; }

    // User Types
    export interface IUserType { [key: string]: number; }
    export type UserTypeKey = keyof IUserType;
    export type UserType = IUserType[UserTypeKey];
    export const OUserType = { SuperAdmin: 1, SystemAdmin: 2, CustomerSupport: 3, TenantAdmin: 4, Physician: 5, Patient: 6 } as const; // @deprecated

    // Tenant Models
    export interface BaseTenant { id: ID; tenancyName: string; countryCode: string; isActive: boolean; createdAt: number; admin?: Partial<BaseUser>; }

    // Group Models
    export interface BaseGroup { id: ID; name: string; description: string; parentGroupId: number; }
    export interface BaseGroupMember extends Pick<BaseUser, 'email' | 'firstName' | 'lastName' | 'userType'> { organizationUserId: ID; userName: string; creationTime: number; }

    // Device Models
    export interface BaseDevice { id: ID; datasourceId: number; name: string; serialNumber: string; softwareVersion: string; state: number; createdAt: number; updatedAt: number; }
    export interface BaseDeviceAssoc { organizationId: ID; startDate: number | null; endDate: number | null; device: BaseDevice; }

    // Data Source Models
    export interface BaseDataSource { id: ID; name: string; key: string; }
    export interface BaseParameterConfig { additionalProp1: string[]; additionalProp2: string[]; additionalProp3: string[]; }
    export interface BaseParameter { id: number; key: string; name: string; type: string; config: BaseParameterConfig; action: string; parentParameterId: number; isNumeric: boolean; isHierarchical: boolean; unit: string; createdAt: number; }
    export interface BaseDataSourceData { id: number; name: string; key: string; parameters: BaseParameter[]; }
    export interface BaseDataSourceDTO { key: string; name: string; action: string; }

    // API Query Models
    export interface BaseApiQuery { q?: string; IsActive?: boolean; Page?: number; PageSize?: number; OrderBy?: string; Direction?: string; UserType?: UserType; }
    export type AsQueryParams<T> = Record<keyof T, string>;

    // Audit Log Models
    export interface BaseLogEntry { id: ID; organizationId: ID; timestamp: number; patientId: ID; lastName: string; firstName: string; statusCode: number; action: string; username: string; userId: ID; }

Best Practices and Gotchas:
- Do: Use these model interfaces for type safety when working with data from APIs
- Do: Extend the base interfaces when you need more specific models rather than creating entirely new ones
- Do: Use the AsQueryParams type when converting objects to query parameters
- Do: Leverage TypeScript utility types like Pick, Partial, and Omit with these base interfaces
- Do: Use the UserType type instead of the deprecated OUserType constant
- Don't: Modify the model interfaces directly; create extended interfaces for specific use cases
- Don't: Use the deprecated OUserType constant; use the UserType type instead
- Don't: Assume all properties are required; check the interface definitions for optional properties
- Don't: Create duplicate interfaces when existing models can be extended or composed

Migration Notes:
- v1.0.0: OUserType constant is deprecated, use UserType type instead
- When upgrading, replace direct usage of OUserType with proper UserType typing
- Ensure all API integrations use the standardized BaseApiQuery interface for consistent query parameter handling

Related Components / Patterns:
- API services that use these models for request and response types
- Form components that use these models for input validation and data binding
- Data display components that render information based on these models
- State management services that store and manipulate these models
- Validation services that work with form data structured according to these models
- The @kebormed/x-kit/tokens module which provides injection tokens for user type information
- The @kebormed/x-kit/validators module which provides form validators that work with these model types

Changelog:
- v1.0.0: Initial release with comprehensive model definitions for users, tenants, groups, devices, data sources, audit logs, and API queries

-----------------------------------------------------------

## File: ./projects/kit/patient/patient-details/patient-details.txt

PatientDetailsComponent - Component Documentation
Status: stable
Since: v1.0.0

Short description: A display component that renders comprehensive patient information in a structured format.

Purpose and Overview:
The PatientDetailsComponent is a read-only display component designed to present detailed patient information in a clean, organized layout. It accepts a BasePatient object and renders all relevant patient data including personal information, contact details, address, account status, and system metadata. The component uses modern Angular features including standalone architecture, OnPush change detection, and the new control flow syntax. It leverages dependency injection for user type name resolution and includes proper null handling for safe data display.

Quick Start:
  Import:
    import { PatientDetailsComponent } from '@kebormed/x-kit/patient';

    @Component({
      imports: [PatientDetailsComponent]
    })
    export class DemoComponent {}

  Minimal usage (HTML):
    <kbm-patient-details [data]="patient()"></kbm-patient-details>

Inputs and Outputs:
- data = input.required<BasePatient | null>()
  Description: The patient data to display. Accepts a BasePatient object or null. When null, the component renders nothing.

Slots and Content Projection:
This component does not support content projection or slots. It renders a fixed layout based on the provided patient data.

Styling and Theming:
- Uses shared stylesheet: projects/kit/_shared/details.scss
- CSS class: .kbm-details for the main container
- Responsive behavior: Basic responsive layout with fixed label widths (150px)
- Styling features:
  * Centered container with 20px margin and 15px padding
  * Arial font family
  * Fixed-width labels for consistent alignment
  * 5px vertical margin between data rows

Accessibility:
- Keyboard: No interactive elements, fully accessible via screen readers
- ARIA: Uses semantic HTML with strong elements for labels and proper paragraph structure
- Color contrast: Inherits from parent theme, no custom colors applied

Visual Examples:
Basic usage:
  - Displays patient information in label-value pairs
  - Shows personal details (name, email, gender, birthdate)
  - Displays contact information (phone, address details)
  - Shows account status (active, locked, pending activation)
  - Includes system metadata (last login, created date, user type)

Behaviors and Lifecycle:
- Uses OnPush change detection strategy for optimal performance
- Implements modern Angular control flow (@let, @if) for template logic
- Automatically handles null data gracefully by rendering nothing
- Uses dependency injection to resolve user type names via USER_TYPE_NAMES token
- Applies date formatting and boolean-to-value transformations via pipes

API Reference:
  Exports:
    export class PatientDetailsComponent {
      data = input.required<BasePatient | null>();
      protected userTypeNames = inject(USER_TYPE_NAMES);
    }

  Dependencies:
    - BasePatient from '@kebormed/x-kit/model'
    - USER_TYPE_NAMES from '@kebormed/x-kit/tokens'
    - DateFormatPipe from '@kebormed/x-core/utils/pipes'
    - BooleanToValuePipe from '@kebormed/x-core/utils/pipes'

  Import Path:
    import { PatientDetailsComponent } from '@kebormed/x-kit/patient';

Best Practices and Gotchas:
- Do: Ensure USER_TYPE_NAMES token is provided in your application
- Do: Use signals for reactive data binding with the input
- Do: Handle null data appropriately in parent components
- Don't: Modify the component's internal structure as it's designed for consistent patient data display
- Don't: Forget to import required pipes if using the component in isolation

Migration Notes:
- v1.0.0: Initial release using modern Angular standalone architecture
- Uses new input() signal API instead of @Input() decorator
- Implements new control flow (@if, @let) instead of structural directives

Related Components / Patterns:
- PatientFormComponent: For editing patient information
- PatientListComponent: For displaying multiple patients in a list
- UserDetailsComponent: Similar pattern for displaying user information
- BasePatient model from '@kebormed/x-kit/model' for data structure
- USER_TYPE_NAMES token from '@kebormed/x-kit/tokens' for user type resolution

Changelog:
- v1.0.0: Initial release with comprehensive patient data display

-----------------------------------------------------------

## File: ./projects/kit/patient/patient-form/patient-form.txt

PatientFormComponent - Component Documentation
Status: stable
Since: v1.0.0

Short description: A comprehensive reactive form component for creating and editing patient information with validation and flexible action templates.

Purpose and Overview:
The PatientFormComponent provides a complete solution for patient data management, extending the BaseForm abstraction to handle patient-specific information. It supports both creation and editing modes, includes comprehensive validation (including async email uniqueness validation), and offers flexible action templates for customizable form submission behavior. The component is designed with accessibility in mind and follows modern Angular patterns with OnPush change detection strategy.

Quick Start:
  Import:
    import { PatientFormComponent } from '@kebormed/x-kit/patient';

    @Component({
      imports: [PatientFormComponent]
    })
    export class DemoComponent {}

  Minimal usage (HTML):
    <kbm-patient-form (save)="onSavePatient($event)"></kbm-patient-form>

Inputs and Outputs:
- @Input() editData: BasePatient | null
  Description: Sets the form to edit mode and populates fields with existing patient data. When provided, the email field becomes disabled and the form emits edit events instead of save events.

- @Output() save: EventEmitter<BasePatient>
  Description: Emitted when the form is submitted in create mode with valid data. Payload contains the complete patient data.

- @Output() edit: EventEmitter<Partial<BasePatient>>
  Description: Emitted when the form is submitted in edit mode with valid data. Payload contains the updated patient data.

Slots and Content Projection:
- FormActionDirective: Custom action template can be provided using the FormActionDirective to replace default submit/reset buttons. The template receives the component instance as context.
  Usage: <kbm-patient-form><ng-template kbmFormAction let-form>...</ng-template></kbm-patient-form>

Styling and Theming:
- Host class: 'kbm-form' is automatically applied
- CSS custom properties: Inherits from shared form styles (../../_shared/form.scss)
- Layout: Flexbox column layout with container queries for responsive behavior
- Form columns: Each field is wrapped in .form-column with data-for attributes for accessibility

Accessibility:
- Keyboard: Standard form navigation with tab order, submit on Enter, reset functionality
- ARIA: Proper labeling with kbm-label components, form control associations
- Form validation: Error states are communicated through Angular's form validation system
- Semantic HTML: Uses proper form elements, fieldsets for radio groups

Visual Examples:
Basic usage and variants:
  - Create Mode:
    <kbm-patient-form (save)="onSavePatient($event)"></kbm-patient-form>

  - Edit Mode:
    <kbm-patient-form
      [editData]="existingPatient"
      (edit)="onEditPatient($event)">
    </kbm-patient-form>

  - Custom Actions:
    <kbm-patient-form #patientForm>
      <ng-template kbmFormAction let-form>
        <button type="submit" [disabled]="!form.valid">Save Patient</button>
        <button type="button" (click)="form.reset($event)">Cancel</button>
      </ng-template>
    </kbm-patient-form>

Behaviors and Lifecycle:
- Form initialization: Creates reactive form with comprehensive validation rules
- Edit mode: When editData is provided, form switches to edit mode, populates fields, and disables email field
- Validation: Uses both synchronous (required, maxLength, email) and asynchronous (uniqueEmail, validDate) validators
- Submission: Automatically handles form submission via @HostListener, emitting appropriate events based on mode
- Reset: Supports form reset functionality that restores to previous values in edit mode

API Reference:
  Exports:
    export class PatientFormComponent extends BaseForm<BasePatient> implements BaseFormAction

  Form Controls:
    - firstName: string (required, max 32 chars)
    - lastName: string (required, max 32 chars)
    - email: string (required, email format, unique validation)
    - patientId: string (max 64 chars)
    - gender: string (radio selection: male/female/unknown)
    - birthdate: string (date validation)
    - phone: string (max 24 chars, uses phone input component)
    - address: string (max 256 chars)
    - address1: string (max 256 chars)
    - countryCode: string (max 64 chars, uses country input component)
    - city: string (max 64 chars)
    - state: string (max 64 chars)
    - postalCode: string (max 16 chars)
    - isActive: boolean (default: true)

  Dependencies:
    - BasePatient from '@kebormed/x-kit/model'
    - uniqueEmail, validDate from '@kebormed/x-kit/validators'
    - Various input components from '@kebormed/x-core/components/input'
    - CountryInputComponent from '@kebormed/x-kit/components/country-input'
    - PhoneInputComponent from '@kebormed/x-kit/components/phone-input'

Best Practices and Gotchas:
- Do: Use the editData input to switch between create and edit modes
- Do: Handle both save and edit output events appropriately
- Do: Provide custom action templates when default buttons don't meet requirements
- Do: Leverage the form's built-in validation before processing submissions
- Don't: Manually manipulate form controls; use the provided inputs and methods
- Don't: Forget that email validation is asynchronous and may take time to complete
- Don't: Submit the form while async validators are still processing

Migration Notes:
- v1.0.0: Initial release with full patient form functionality

Related Components / Patterns:
- BaseForm abstraction from '@kebormed/x-core/abstraction/form'
- BasePatient model from '@kebormed/x-kit/model'
- Custom validators from '@kebormed/x-kit/validators'
- Input components from '@kebormed/x-core/components/input'
- CountryInputComponent and PhoneInputComponent for specialized inputs
- FormActionDirective for custom action templates

Changelog:
- v1.0.0: Initial release with comprehensive patient form functionality

-----------------------------------------------------------

## File: ./projects/kit/patient/patient-list/patient-list.txt

PatientListComponent - Component Documentation
Status: stable
Since: v1.0.0

Short description: A responsive table/accordion component for displaying patient data with sorting capabilities and action templates.

Purpose and Overview:
The PatientListComponent is a responsive data display component that renders patient information in two different layouts based on screen size. On larger screens, it displays patients in a sortable table format with columns for patient ID, first name, last name, and active status. On smaller screens, it switches to an accordion layout for better mobile usability. The component extends BaseTable<BasePatient> and provides sorting functionality and customizable action templates for each patient record.

Quick Start:
  Import:
    import { PatientListComponent } from '@kebormed/x-kit/patient';

    @Component({
      selector: 'app-demo',
      imports: [PatientListComponent],
      template: `<kbm-patient-list [data]="patients" (sort)="onSort($event)"></kbm-patient-list>`
    })
    export class DemoComponent {}

  Minimal usage (HTML):
    <kbm-patient-list [data]="patientData" (sort)="handleSort($event)"></kbm-patient-list>

Inputs and Outputs:
- @Input() data: BasePatient[] = []
  Description: Array of patient objects to display. Each patient should conform to the BasePatient interface from @kebormed/x-kit/model.

- @Output() sort: EventEmitter<SortEvt>
  Description: Emitted when user clicks on sortable column headers. Payload contains field name and sort direction information.

Slots and Content Projection:
The component supports action templates through the actionTemplate property inherited from BaseTable. Action templates are displayed as the last column in table view and at the bottom of each accordion item in mobile view.

Template usage:
```html
<kbm-patient-list [data]="patients" (sort)="onSort($event)">
  <ng-template #actionTemplate let-patient>
    <button (click)="editPatient(patient)">Edit</button>
    <button (click)="deletePatient(patient)">Delete</button>
  </ng-template>
</kbm-patient-list>
```

Styling and Theming:
- The component has no custom SCSS styles and relies on inherited styles from base components
- Responsive behavior is handled through the isSmallScreen$ observable from @kebormed/x-kit/services
- Table styling comes from TableModule (@kebormed/x-core/components/table)
- Accordion styling comes from AccordionComponent (@kebormed/x-core/components/accordion)
- Breakpoint behavior is determined by the isSmallScreen$ service

Accessibility:
- Keyboard: Table columns support keyboard navigation and sorting via Enter/Space keys through ColumnSortDirective
- ARIA: Inherits ARIA support from base table and accordion components
- Color contrast: Follows design system standards through base component styling
- Screen readers: Patient information is properly structured in both table and accordion formats

Visual Examples:
Basic usage and variants:
  - Desktop View: Displays as a sortable table with columns for Patient ID, First Name, Last Name, and Active status
  - Mobile View: Displays as an accordion with patient details in expandable items
  - States:
    * Loading: Handled by parent component
    * Empty: Shows empty table/accordion when data array is empty
    * Sorted: Visual indicators on column headers show current sort state

Behaviors and Lifecycle:
- The component uses OnPush change detection strategy for optimal performance
- Responsive behavior is handled through the isSmallScreen$ observable which automatically updates the view
- Sorting is delegated to the parent component through the sort output event
- The component extends BaseTable<BasePatient> which provides common table functionality
- Patient titles in accordion view are generated using the title() method: "#${patientId} ${firstName} ${lastName}"

API Reference:
  Exports:
    export class PatientListComponent extends BaseTable<BasePatient>

  Dependencies:
    - BasePatient from @kebormed/x-kit/model
    - BaseTable from @kebormed/x-core/components/table
    - SortEvt from @kebormed/x-core/components/sort
    - isSmallScreen$ from @kebormed/x-kit/services
    - PatientDetailsComponent from ../patient-details/patient-details.component

  Methods:
    - actionContext(data: unknown): ContextWithImplicit<BasePatient>
      Creates context object for action template with patient data
    - title(patient: BasePatient): string
      Generates display title for accordion items

Best Practices and Gotchas:
- Do: Provide action templates for interactive functionality (edit, delete, view details)
- Do: Handle the sort event to implement server-side or client-side sorting
- Do: Use BasePatient interface for type safety
- Do: Consider loading states when fetching patient data
- Don't: Modify the data array directly; use immutable updates for better change detection
- Don't: Forget to handle empty states gracefully
- Don't: Assume the component will handle data fetching; it's a presentation component only

Migration Notes:
- v1.0.0: Initial release - no migration needed

Related Components / Patterns:
- PatientDetailsComponent: Used internally to display patient information in accordion view
- BaseTable: Parent class providing common table functionality
- TableModule: Provides table display capabilities for desktop view
- AccordionComponent: Provides accordion display for mobile view
- Similar pattern used in other list components throughout the kit library

Changelog:
- v1.0.0: Initial release

-----------------------------------------------------------

## File: ./projects/kit/services/services.txt

---
title: Services
status: stable
since: v1.0.0
---

# `@kebormed/x-kit/services` • Services Documentation
> A collection of Angular services for API communication, validation, layout observation, and dependency injection tokens.

---

## 1. Purpose & Overview
The Services module provides a comprehensive set of Angular services that handle various aspects of application functionality including API communication, form validation, layout responsiveness, and dependency injection. These services are designed to work together to provide a cohesive development experience while maintaining separation of concerns and promoting reusability across the application.

The module includes:
- **BaseApiService**: Abstract base class for API services with common HTTP functionality
- **SystemAdminService**: Complete CRUD operations for system administration (tenants, users, devices, data sources)
- **ValidationService**: Backend validation for form uniqueness checks
- **AbstractValidationService**: Abstract contract for validation services
- **Layout Observer**: Utility function for responsive design breakpoint detection
- **Injection Tokens**: Dependency injection tokens for service provision

## 2. Quick Start
```ts
// 2.1. Import services
import {
  SystemAdminService,
  ValidationService,
  KBM_VALIDATION_SERVICE,
  isSmallScreen$
} from '@kebormed/x-kit/services';
import { inject } from '@angular/core';

// 2.2. Usage examples
@Component({
  selector: 'app-admin-dashboard',
  template: `
    @if (isSmallScreen()) {
      <div class="mobile-layout">Mobile View</div>
    } @else {
      <div class="desktop-layout">Desktop View</div>
    }
  `,
  changeDetection: ChangeDetectionStrategy.OnPush
})
export class AdminDashboardComponent {
  private systemAdminService = inject(SystemAdminService);
  private validationService = inject(KBM_VALIDATION_SERVICE);

  protected readonly isSmallScreen = toSignal(isSmallScreen$(), { initialValue: false });

  async loadTenants() {
    const tenants = await firstValueFrom(this.systemAdminService.getTenants());
    return tenants;
  }

  async validateEmail(email: string) {
    const validation = await firstValueFrom(this.validationService.isEmailUnique(email));
    return validation;
  }
}
```

## 3. Available Services

### Core Services
| Name | Type | Description |
|------|------|-------------|
| `BaseApiService` | Abstract Class | Base class for API services providing common HTTP functionality and parameter conversion utilities. |
| `SystemAdminService` | Injectable Service | Comprehensive service for system administration operations including tenant, user, device, and data source management. |
| `ValidationService` | Class | Concrete implementation of validation service for checking entity uniqueness via backend API calls. |
| `AbstractValidationService` | Abstract Class | Abstract contract defining validation methods that concrete validation services must implement. |

### Utility Functions
| Name | Type | Description |
|------|------|-------------|
| `isSmallScreen$()` | Function | Returns an observable that emits boolean values indicating whether the screen matches small screen breakpoint (max-width: 900px). |

### Injection Tokens
| Name | Type | Description |
|------|------|-------------|
| `KBM_VALIDATION_SERVICE` | InjectionToken | Injection token for ValidationService, provided in root with factory function. |

## 4. Service Implementations

### BaseApiService
```ts
export abstract class BaseApiService {
  protected baseUrl = inject(API_BASE_URL);
  protected http = inject(HttpClient);

  toHttpParams(params?: BaseApiQuery): HttpParams {
    if (!params) {
      return new HttpParams();
    }
    return new HttpParams({fromObject: kbmOnlyPresentValues(params)});
  }
}
```

### SystemAdminService
The SystemAdminService provides comprehensive CRUD operations organized by domain:

**Tenant Management:**
- `getTenants<T, P>(params?: P)` - Retrieve paginated list of tenants
- `getTenant<T>(tenantId: ID)` - Get specific tenant by ID
- `createTenant<T>(tenant: Partial<BaseTenant>)` - Create new tenant
- `updateTenant<T>(tenantId: number, tenant: Partial<BaseTenant>)` - Update existing tenant
- `deleteTenant(tenantId: number)` - Delete tenant

**System User Management:**
- `getSystemUsers<T, P>(params?: P)` - Retrieve paginated list of system users
- `createSystemUser<T>(user: Partial<BaseUser>)` - Create new system user
- `updateSystemUser<T>(userId: ID, user: Partial<BaseUser>)` - Update existing system user
- `deleteSystemUser(userId: ID)` - Delete system user

**Data Source Management:**
- `getDataSources<T, P>(params?: P)` - Retrieve paginated list of data sources
- `getDataSource<T>(id: ID)` - Get specific data source by ID
- `createDataSource<T>(dataSource: BaseDataSourceDTO)` - Create new data source
- `updateDataSource<T>(id: ID, dataSource: Partial<BaseDataSourceDTO>)` - Update existing data source
- `deleteDataSource(id: ID)` - Delete data source

**Device Management:**
- `getDevices<T, P>(params?: P)` - Retrieve paginated list of devices
- `getDevice<T>(id: ID)` - Get specific device by ID
- `createDevice<T>(device: Partial<BaseDevice>)` - Create new device
- `updateDevice<T>(id: ID, device: Partial<BaseDevice>)` - Update existing device
- `deleteDevice(id: ID)` - Delete device

### ValidationService
```ts
export class ValidationService extends BaseApiService {
  isTenantNameUnique(name: string): Observable<ValidationErrors | null>;
  isEmailUnique(email: string): Observable<ValidationErrors | null>;
  isUsernameUnique(username: string): Observable<ValidationErrors | null>;
  isSerialNumberUnique(serialNumber: string): Observable<ValidationErrors | null>;
  isGroupNameUnique(name: string): Observable<ValidationErrors | null>;
}
```

### Layout Observer
```ts
export function isSmallScreen$(): Observable<boolean> {
  return inject(BreakpointObserver)
    .observe(['(max-width: 900px)'])
    .pipe(
      map(({matches}) => matches),
      shareReplay({refCount: true, bufferSize: 1}),
    );
}
```

## 5. Usage Examples

### System Administration Operations
```ts
import { Component, inject } from '@angular/core';
import { SystemAdminService } from '@kebormed/x-kit/services';
import { BaseTenant, BaseUser } from '@kebormed/x-kit/model';

@Component({
  selector: 'app-tenant-management',
  template: `
    <div class="tenant-list">
      @for (tenant of tenants(); track tenant.id) {
        <div class="tenant-card">
          <h3>{{ tenant.tenancyName }}</h3>
          <p>Active: {{ tenant.isActive ? 'Yes' : 'No' }}</p>
          <button (click)="deleteTenant(tenant.id)">Delete</button>
        </div>
      }
    </div>
  `,
  changeDetection: ChangeDetectionStrategy.OnPush
})
export class TenantManagementComponent {
  private systemAdminService = inject(SystemAdminService);

  protected readonly tenants = signal<BaseTenant[]>([]);

  async ngOnInit() {
    await this.loadTenants();
  }

  private async loadTenants() {
    try {
      const response = await firstValueFrom(
        this.systemAdminService.getTenants({ Page: 1, PageSize: 50 })
      );
      this.tenants.set(response.items);
    } catch (error) {
      console.error('Failed to load tenants:', error);
    }
  }

  async deleteTenant(tenantId: number) {
    try {
      await firstValueFrom(this.systemAdminService.deleteTenant(tenantId));
      await this.loadTenants(); // Refresh the list
    } catch (error) {
      console.error('Failed to delete tenant:', error);
    }
  }

  async createTenant(tenantData: Partial<BaseTenant>) {
    try {
      await firstValueFrom(this.systemAdminService.createTenant(tenantData));
      await this.loadTenants(); // Refresh the list
    } catch (error) {
      console.error('Failed to create tenant:', error);
    }
  }
}
```

### Form Validation with ValidationService
```ts
import { Component, inject } from '@angular/core';
import { FormBuilder, Validators } from '@angular/forms';
import { KBM_VALIDATION_SERVICE } from '@kebormed/x-kit/services';
import { uniqueEmail, uniqueUsername } from '@kebormed/x-kit/validators';

@Component({
  selector: 'app-user-registration',
  template: `
    <form [formGroup]="registrationForm" (ngSubmit)="onSubmit()">
      <div>
        <label for="email">Email</label>
        <input id="email" type="email" formControlName="email">
        @if (emailControl?.errors?.['email']) {
          <span class="error">Please enter a valid email address</span>
        }
        @if (emailControl?.errors?.['uniqueEmail']) {
          <span class="error">This email is already in use</span>
        }
      </div>

      <div>
        <label for="username">Username</label>
        <input id="username" type="text" formControlName="username">
        @if (usernameControl?.errors?.['uniqueUsername']) {
          <span class="error">This username is already taken</span>
        }
      </div>

      <button type="submit" [disabled]="registrationForm.invalid">
        Register
      </button>
    </form>
  `,
  changeDetection: ChangeDetectionStrategy.OnPush
})
export class UserRegistrationComponent {
  private fb = inject(FormBuilder);
  private validationService = inject(KBM_VALIDATION_SERVICE);

  protected readonly registrationForm = this.fb.group({
    email: ['', [
      Validators.required,
      Validators.email
    ], [
      uniqueEmail()
    ]],
    username: ['', [
      Validators.required,
      Validators.minLength(3)
    ], [
      uniqueUsername()
    ]]
  });

  get emailControl() {
    return this.registrationForm.get('email');
  }

  get usernameControl() {
    return this.registrationForm.get('username');
  }

  onSubmit() {
    if (this.registrationForm.valid) {
      console.log('Form submitted:', this.registrationForm.value);
    }
  }
}
```

### Responsive Layout with Layout Observer
```ts
import { Component } from '@angular/core';
import { isSmallScreen$ } from '@kebormed/x-kit/services';
import { toSignal } from '@angular/core/rxjs-interop';

@Component({
  selector: 'app-responsive-layout',
  template: `
    <div [class]="layoutClass()">
      @if (isSmallScreen()) {
        <nav class="mobile-nav">
          <button (click)="toggleMenu()">☰</button>
        </nav>
      } @else {
        <nav class="desktop-nav">
          <a href="/dashboard">Dashboard</a>
          <a href="/users">Users</a>
          <a href="/settings">Settings</a>
        </nav>
      }

      <main class="content">
        <ng-content></ng-content>
      </main>
    </div>
  `,
  changeDetection: ChangeDetectionStrategy.OnPush
})
export class ResponsiveLayoutComponent {
  protected readonly isSmallScreen = toSignal(isSmallScreen$(), { initialValue: false });

  protected readonly layoutClass = computed(() =>
    this.isSmallScreen() ? 'mobile-layout' : 'desktop-layout'
  );

  toggleMenu() {
    // Mobile menu toggle logic
  }
}
```

### Custom API Service Extension
```ts
import { Injectable } from '@angular/core';
import { BaseApiService } from '@kebormed/x-kit/services';
import { BaseUser, BaseApiQuery } from '@kebormed/x-kit/model';
import { Observable } from 'rxjs';

@Injectable({
  providedIn: 'root'
})
export class UserService extends BaseApiService {
  getUsers<T extends BaseUser = BaseUser, P extends BaseApiQuery = BaseApiQuery>(
    params?: P
  ): Observable<ApiWrapper<T>> {
    return this.http.get<ApiWrapper<T>>(`${this.baseUrl}/users`, {
      params: this.toHttpParams(params)
    });
  }

  getUserProfile<T extends BaseUser = BaseUser>(userId: ID): Observable<T> {
    return this.http.get<T>(`${this.baseUrl}/user/${userId}/profile`);
  }

  updateUserProfile<T extends Partial<BaseUser> = BaseUser>(
    userId: ID,
    profile: Partial<BaseUser>
  ): Observable<HttpResponse<unknown>> {
    return this.http.put<T>(`${this.baseUrl}/user/${userId}/profile`, profile, {
      observe: 'response'
    });
  }
}
```

## 6. Best Practices & Gotchas
* Do ✔️ Extend BaseApiService when creating new API services to inherit common functionality
* Do ✔️ Use the SystemAdminService for all system administration operations rather than creating separate services
* Do ✔️ Use the KBM_VALIDATION_SERVICE injection token instead of directly instantiating ValidationService
* Do ✔️ Leverage the generic type parameters in SystemAdminService methods for better type safety
* Do ✔️ Use isSmallScreen$() with toSignal() for reactive responsive design in components
* Do ✔️ Handle errors appropriately when using validation services as they make HTTP requests
* Don't ❌ Instantiate ValidationService directly; use the injection token for proper dependency injection
* Don't ❌ Forget to handle loading states when using async validation methods
* Don't ❌ Use isSmallScreen$() without shareReplay as it's already optimized for multiple subscriptions
* Don't ❌ Override the toHttpParams method in BaseApiService unless you have specific requirements

## 7. API Reference
<details>
<summary>Exports</summary>

The module exports the following services, classes, functions, and tokens:

**Abstract Classes:**
- `BaseApiService` - Abstract base class for API services with HTTP utilities
- `AbstractValidationService` - Abstract contract for validation services

**Services:**
- `SystemAdminService` - Injectable service for system administration operations
- `ValidationService` - Concrete validation service implementation

**Utility Functions:**
- `isSmallScreen$(): Observable<boolean>` - Responsive breakpoint observer function

**Injection Tokens:**
- `KBM_VALIDATION_SERVICE: InjectionToken<ValidationService>` - Dependency injection token for ValidationService
</details>

## 8. Related Components / Patterns
* Form validators from `@kebormed/x-kit/validators` that use the ValidationService
* Model interfaces from `@kebormed/x-kit/model` used as type parameters in service methods
* Core utilities from `@kebormed/x-core` used by BaseApiService
* Angular CDK Layout module used by the layout observer function
* Reactive forms that integrate with validation services
* Admin dashboard components that use SystemAdminService
* Responsive components that use layout observer utilities

---

### Changelog
| Version | Changes |
|---------|---------|
| 1.0.0 | Initial release |

-----------------------------------------------------------

## File: ./projects/kit/tenant/tenant-form/tenant-form.txt

TenantForm - Component Documentation
Status: stable
Since: v1.1.0

Short description: A reactive form component for creating and editing tenant information with integrated admin user management.

Purpose and Overview:
The TenantFormComponent provides a standardized, type-safe form for managing tenant data in the system. It extends the BaseForm<BaseTenant> class to leverage common form functionality and implements the BaseFormAction interface for consistent form behavior. The component handles both creation and editing modes, with automatic validation including async uniqueness checks for tenant names, admin emails, and usernames. When creating a new tenant, it collects admin user information; when editing, it focuses only on tenant properties while disabling admin fields. The component uses modern Angular patterns including standalone architecture, signals-based outputs, OnPush change detection, and the new control flow syntax.

Quick Start:
  Import:
    import { TenantFormComponent } from '@kebormed/x-kit/tenant';
    @Component({
      imports: [TenantFormComponent]
    })
    export class DemoComponent {}

  Minimal usage (HTML):
    <kbm-tenant-form (save)="onSaveTenant($event)"></kbm-tenant-form>

Inputs and Outputs:
- @Input() editData: BaseTenant | null = null
  Description: Sets the form in edit mode with the provided tenant data. When provided, the form is pre-populated with existing values, admin fields are disabled, and the component switches to edit mode behavior.

- save: OutputEmitterRef<BaseTenant>
  Description: Emitted when the form is submitted in create mode with valid tenant data including admin user information. Uses modern output() function instead of @Output() decorator.

- edit: OutputEmitterRef<Partial<BaseTenant>>
  Description: Emitted when the form is submitted in edit mode with modified tenant data. Admin information is excluded from the payload as it cannot be modified in edit mode.

Slots and Content Projection:
The component supports custom form actions through the FormActionDirective:
- FormActionDirective: Allows projection of custom action buttons into the form. The template context provides access to the form component instance ($implicit: TenantFormComponent). When no custom actions are provided, default Submit and Reset buttons are displayed.

Example:
<kbm-tenant-form>
  <ng-template kbmFormAction let-form>
    <button type="submit" [disabled]="!form.valid" kbm-button>Save Tenant</button>
    <button type="button" (click)="form.reset($event)" kbm-button>Cancel</button>
  </ng-template>
</kbm-tenant-form>

Styling and Theming:
- Uses shared form styling from '../../_shared/form.scss' for consistent layout
- Host element configured as flex column with container-type: inline-size for container queries
- CSS class 'kbm-form' applied to host element for styling hooks
- Responsive grid layout adapts to different screen sizes:
  * Large screens: 3 columns
  * Medium screens: 2 columns
  * Small screens: 1 column
- CSS variables available for customization:
  * --form-layout-cols-lg: Number of columns on large screens
  * --form-layout-cols-md: Number of columns on medium screens
  * --form-layout-cols-sm: Number of columns on small screens
  * --gap: Gap between form elements

Accessibility:
- Keyboard: All form controls are keyboard navigable using Tab key. Submit and Reset buttons support keyboard activation.
- ARIA: Standard form controls with proper label associations via kbm-label components.
- Color contrast: Inherits from application's color scheme and design system.

Visual Examples:
Basic usage and variants:
  - Create Mode
    Displays all fields: tenant name, country selection, admin user details (first name, last name, email, username, phone), and active status checkbox.
  - Edit Mode
    Shows only tenant fields (name, country, active status) with admin section hidden and disabled.
  - Custom Actions
    Allows replacement of default Submit/Reset buttons with custom action templates.

Behaviors and Lifecycle:
The component extends BaseForm<BaseTenant> and implements BaseFormAction for consistent form behavior. It uses reactive forms with comprehensive validation including required field validation, email format validation, maximum length constraints, and async uniqueness validation for tenant names, admin emails, and usernames via @kebormed/x-kit/validators. The form automatically switches between create and edit modes based on the editData input. In create mode, all fields are enabled and the save output emits complete BaseTenant data. In edit mode, admin fields are disabled via setDisabled(['admin'], true) and the edit output emits partial tenant data. The component uses OnPush change detection strategy for optimal performance and modern Angular patterns including the output() function for event emission and @if control flow in templates. Form reset functionality restores the previous values stored in _previousValue property.

API Reference:
  Exports:
    export class TenantFormComponent extends BaseForm<BaseTenant> implements BaseFormAction

    Properties:
    - form: FormGroup - Reactive form with tenant and admin controls
    - _previousValue: Partial<BaseTenant> - Stores previous form values for reset
    - actionTemplate: FormActionDirective - Template for custom form actions

    Form Structure:
    - tenancyName: FormControl<string> - Required, max 32 chars, uniqueTenantName() async validator
    - countryCode: FormControl<string> - Required
    - isActive: FormControl<boolean> - Required, defaults to true
    - admin: FormGroup - Nested group for admin user (disabled in edit mode)
      - firstName: FormControl<string> - Required, max 32 chars
      - lastName: FormControl<string> - Required, max 32 chars
      - email: FormControl<string> - Required, email format, uniqueEmail() async validator
      - username: FormControl<string> - Required, max 32 chars, uniqueUsername() async validator
      - phone: FormControl<string> - Optional, max 24 chars

    Inputs:
    - editData: BaseTenant | null - Sets edit mode and pre-populates form

    Outputs (using modern output() function):
    - save: OutputEmitterRef<BaseTenant> - Emitted on create mode submission
    - edit: OutputEmitterRef<Partial<BaseTenant>> - Emitted on edit mode submission

    Methods:
    - submit(): void - Handles form submission with @HostListener('submit')
    - reset(event: Event): void - Resets form to previous state with @HostListener('reset')

    Dependencies:
    - BaseTenant, BaseUser from @kebormed/x-kit/model
    - uniqueEmail, uniqueTenantName, uniqueUsername from @kebormed/x-kit/validators
    - BaseForm from @kebormed/x-core/abstraction/form
    - FormActionDirective from @kebormed/x-core/components/form
    - Input components from @kebormed/x-core/components/input
    - CountryInputComponent, PhoneInputComponent from @kebormed/x-kit/components

Best Practices and Gotchas:
- Do: Use the editData input for editing existing tenants
- Do: Handle both save and edit outputs in parent components
- Do: Use FormActionDirective for custom form actions when needed
- Do: Check form validity before programmatic submission
- Don't: Attempt to modify admin information in edit mode (fields are disabled)
- Don't: Submit the form while async validators are processing
- Don't: Forget to handle loading states during async validation

Migration Notes:
- v1.1.0: Updated to use modern Angular patterns including output() function, @if control flow, and improved validator documentation
- v1.0.0: Initial release

Related Components / Patterns:
- TenantListComponent: For displaying and managing multiple tenants
- BaseForm: Abstract class providing common form functionality
- BaseTenant and BaseUser models from @kebormed/x-kit/model
- Validators from @kebormed/x-kit/validators: uniqueEmail, uniqueTenantName, uniqueUsername
- FormActionDirective from @kebormed/x-core/components/form
- CountryInputComponent and PhoneInputComponent for specialized input handling

Changelog:
- v1.1.0: Updated documentation to reflect modern Angular patterns, corrected outputs to use output() function, added detailed validator specifications, documented BaseFormAction interface implementation
- v1.0.0: Initial release

-----------------------------------------------------------

## File: ./projects/kit/tenant/tenant-list/tenant-list.txt

TenantListComponent - Component Documentation
Status: stable
Since: v1.0.0

Short description: A table component for displaying and sorting tenant data with support for custom action templates.

Purpose and Overview:
The TenantListComponent provides a standardized way to display tenant information in a tabular format. It extends the BaseTable component from the core library and allows for sorting of tenant data. The component displays tenant name, active status (using a boolean-to-value pipe), and creation date (formatted with Angular's date pipe), with support for custom action templates through content projection. This component is designed to be reusable across different parts of the application where tenant data needs to be displayed in a consistent manner.

Quick Start:
  Import:
    import { TenantListComponent } from '@kebormed/x-kit/tenant';
    import { CommonModule } from '@angular/common';
    import type { BaseTenant } from '@kebormed/x-kit/model';

    @Component({
      selector: 'app-tenant-management',
      standalone: true,
      imports: [CommonModule, TenantListComponent],
      template: `
        <kbm-tenant-list
          [data]="tenants"
          (sort)="handleSort($event)">
          <ng-template #actionTemplate let-tenant>
            <button (click)="editTenant(tenant)">Edit</button>
            <button (click)="deleteTenant(tenant)">Delete</button>
          </ng-template>
        </kbm-tenant-list>
      `,
      changeDetection: ChangeDetectionStrategy.OnPush
    })
    export class TenantManagementComponent {
      protected tenants: BaseTenant[] = [];

      handleSort(event: SortEvt): void {
        // Handle sorting logic
      }
    }

  Minimal usage (HTML):
    <kbm-tenant-list [data]="tenants" (sort)="handleSort($event)"></kbm-tenant-list>

Inputs and Outputs:
- @Input() data: BaseTenant[] = []
  Description: Sets the array of tenant data to display in the table. Each tenant object should conform to the BaseTenant interface from @kebormed/x-kit/model, containing properties like id, tenancyName, isActive, createdAt, and countryCode.

- @Output() sort: EventEmitter<SortEvt>
  Description: Emitted when a column sort is triggered. The event contains sorting information including the field name and direction. This allows parent components to implement custom sorting logic or update data sources accordingly.

Slots and Content Projection:
The component supports content projection for customizing the action column:
- #actionTemplate: Template reference for the action column. The template receives the row data (BaseTenant object) as context through the let-tenant syntax. This allows for flexible customization of actions available for each tenant row, such as edit, delete, or view details buttons.

Styling and Theming:
- The component inherits all styling from the underlying kbm-table component from the core library
- No additional SCSS variables or CSS custom properties are exposed by this component
- The component's SCSS file is empty, relying entirely on the base table styling
- Responsive behavior and breakpoints are inherited from the core table component
- For custom styling, wrap the component or apply styles to the parent container

Accessibility:
- Keyboard: Inherits keyboard navigation from the underlying kbm-table component, including tab navigation and sortable column interactions
- ARIA: Inherits ARIA attributes from the underlying kbm-table component, including proper table semantics, column headers, and sort state announcements
- Color contrast: Inherits color contrast considerations from the underlying kbm-table component, ensuring WCAG compliance

Visual Examples:
Basic usage and variants:
  - Basic:
    <kbm-tenant-list [data]="tenants" (sort)="handleSort($event)"></kbm-tenant-list>
    Displays a table with columns for Tenant Name, Active status, and Created At date.

  - With Custom Actions:
    <kbm-tenant-list [data]="tenants" (sort)="handleSort($event)">
      <ng-template #actionTemplate let-tenant>
        <button (click)="editTenant(tenant)">Edit</button>
        <button (click)="deleteTenant(tenant)">Delete</button>
      </ng-template>
    </kbm-tenant-list>
    Adds custom action buttons for each tenant row.

  - States:
    * Loading state: Handled by parent component by providing empty array or loading indicator
    * Empty state: Displays empty table when data array is empty
    * Error state: Handled by parent component through error handling in sort event

Behaviors and Lifecycle:
The component extends BaseTable<BaseTenant> and inherits its behaviors. It displays tenant data in a table with sortable columns for tenant name (tenancyName), active status (isActive), and creation date (createdAt). The active status is formatted using the BooleanToValuePipe, and the creation date is formatted using Angular's date pipe with 'dd/MM/yyyy' format. The component uses OnPush change detection strategy for optimal performance. Sorting is handled by emitting sort events to the parent component, allowing for flexible data management strategies.

API Reference:
  Exports:
    export class TenantListComponent extends BaseTable<BaseTenant> {
      @Input() data: BaseTenant[] = [];
      @Output() sort = new EventEmitter<SortEvt>();
    }

    Dependencies:
    - BaseTable<BaseTenant> from '@kebormed/x-core/components'
    - BaseTenant interface from '@kebormed/x-kit/model'
    - SortEvt type from '@kebormed/x-core/components'
    - BooleanToValuePipe from '@kebormed/x-core'

    Import path: '@kebormed/x-kit/tenant'

Best Practices and Gotchas:
- Do: Provide an action template when you need custom actions for each tenant
- Do: Handle the sort event to implement sorting functionality in the parent component
- Do: Use with a data source that provides BaseTenant objects conforming to the model interface
- Do: Implement proper loading and error states in the parent component
- Don't: Modify the component's internal structure or styling directly
- Don't: Assume the component handles pagination; implement pagination separately if needed
- Don't: Forget to handle the sort event, as the component doesn't perform sorting internally

Migration Notes:
Not applicable for initial release.

Related Components / Patterns:
- BaseTable from '@kebormed/x-core/components' - The base table component that this component extends
- BaseTenant interface from '@kebormed/x-kit/model' - The data model used by this component
- BooleanToValuePipe from '@kebormed/x-core' - Used to format the active status display
- Tenant form components for creating and editing tenants
- Other list components that follow similar patterns, such as user lists or group lists
- SortEvt type from '@kebormed/x-core/components' - Used for sort event handling

Changelog:
- v1.0.0: Initial release

-----------------------------------------------------------

## File: ./projects/kit/tokens/tokens.txt

Tokens - Component Documentation
Status: stable
Since: v1.0.0

Short description: A collection of Angular injection tokens for dependency injection of user type information throughout the application.

Purpose and Overview:
The Tokens module provides a set of Angular injection tokens that facilitate dependency injection of user type information throughout the application. These tokens allow components and services to access user type data and names without direct dependencies on concrete implementations, promoting loose coupling and easier testing. By centralizing these tokens, the module ensures consistency in how user type information is accessed across the application. The tokens are designed to work with the type definitions from @kebormed/x-kit/model, specifically IUserType and UserType interfaces.

Quick Start:
  Import:
    import { USER_TYPES, USER_TYPE_NAMES } from '@kebormed/x-kit/tokens';
    import { IUserType, UserType } from '@kebormed/x-kit/model';

  Minimal usage (TypeScript):
    // In a component or service
    constructor(
      @Inject(USER_TYPES) private userTypes: IUserType,
      @Inject(USER_TYPE_NAMES) private userTypeNames: Record<UserType, string>
    ) {}

Inputs and Outputs:
- USER_TYPES: InjectionToken<IUserType>
  Description: Provides access to user type information through dependency injection. The token expects a value of type IUserType which maps string keys to numeric user type identifiers.

- USER_TYPE_NAMES: InjectionToken<Record<UserType, string>>
  Description: Provides access to a mapping of user type identifiers to their display names. The token expects a value of type Record<UserType, string> for user-friendly display of user types.

Slots and Content Projection:
Not applicable - these are injection tokens, not components with templates.

Styling and Theming:
Not applicable - these are injection tokens without visual representation.

Accessibility:
Not applicable - these are injection tokens used for data access, not UI components.

Visual Examples:
Not applicable - these are injection tokens without visual representation.

Behaviors and Lifecycle:
The tokens follow Angular's dependency injection lifecycle. They are resolved at injection time and provide access to the configured user type data. The tokens are typically provided at the module or application level and injected into components and services that need user type information. Performance is optimized through Angular's singleton injection pattern when provided at the root level.

API Reference:
  Exports:
    export const USER_TYPES = new InjectionToken<IUserType>('USER_TYPES');
    export const USER_TYPE_NAMES = new InjectionToken<Record<UserType, string>>('USER_TYPE_NAMES');

  Related Types (from @kebormed/x-kit/model):
    export interface IUserType {
      [key: string]: number;
    }
    export type UserTypeKey = keyof IUserType;
    export type UserType = IUserType[UserTypeKey];

Best Practices and Gotchas:
- Do: Provide values for these tokens at the highest appropriate level in your application (typically at the module or root level)
- Do: Use the @Inject decorator when injecting these tokens in constructors
- Do: Consider using factory providers for dynamic token values that need to be computed at runtime
- Do: Import the required types from @kebormed/x-kit/model when working with these tokens
- Do: Implement proper error handling when the token values might not be available
- Don't: Forget to provide values for these tokens before attempting to inject them
- Don't: Create circular dependencies between modules that provide and consume these tokens
- Don't: Assume token values are always available without proper null checking

Migration Notes:
- v1.0.0: Initial release with USER_TYPES and USER_TYPE_NAMES tokens
- The tokens work with the IUserType interface which replaced the deprecated OUserType constant object
- When migrating from direct usage of OUserType, update code to use the injection tokens instead

Related Components / Patterns:
- User management components (user-form, user-list, user-details) that display or filter by user types
- HCP components (hcp-form, hcp-list) that handle healthcare provider user types
- Group components (group-member-list) that show user roles within groups
- Patient components (patient-details) that display patient user type information
- Authorization services that use user types for permission checks
- The @kebormed/x-kit/model module which provides the IUserType and UserType type definitions
- The @kebormed/x-kit/validators module which may validate user type selections in forms

Changelog:
- v1.0.0: Initial release with USER_TYPES and USER_TYPE_NAMES injection tokens

-----------------------------------------------------------

## File: ./projects/kit/user/user-details/user-details.txt

UserDetailsComponent - Component Documentation
Status: stable
Since: v1.0.0

Short description: A display component that renders detailed user information in a structured format with proper labeling and formatting.

Purpose and Overview:
The UserDetailsComponent is a presentation component designed to display comprehensive user information in a clean, structured layout. It accepts a BaseUser object and renders all relevant user properties including personal information, contact details, account status, and metadata. The component uses modern Angular patterns with signals, standalone architecture, and OnPush change detection for optimal performance. It leverages dependency injection for user type name resolution and includes proper null handling for safe data display.

Quick Start:
  Import:
    import { UserDetailsComponent } from '@kebormed/x-kit/user';

    @Component({
      imports: [UserDetailsComponent]
    })
    export class DemoComponent {}

  Minimal usage (HTML):
    <kbm-user-details [data]="user"></kbm-user-details>

Inputs and Outputs:
- data = input.required<BaseUser | null>()
  Description: The user data to display. Accepts a BaseUser object or null. When null, the component renders nothing.

Slots and Content Projection:
No content projection or slots are supported. The component renders a fixed layout of user information fields.

Styling and Theming:
- Uses shared styling from `projects/kit/_shared/details.scss`
- CSS class: `.kbm-details` provides consistent spacing and typography
- Labels have fixed width (150px) for consistent alignment
- Responsive behavior: Uses Arial font family with standard margins and padding
- No custom CSS properties exposed; styling is handled through shared stylesheet

Accessibility:
- Keyboard: No interactive elements, so no specific keyboard navigation
- ARIA: Uses semantic HTML with proper label-value structure using <strong> tags for labels
- Color contrast: Inherits from parent theme; no specific color styling applied

Visual Examples:
Basic usage and variants:
  - Basic: Displays all user fields in a structured list format with labels and values
  - Null state: Renders nothing when data input is null
  - Data formatting: Boolean values are converted to readable text, dates are formatted, and user types show human-readable names

Behaviors and Lifecycle:
- Uses OnPush change detection strategy for optimal performance
- Leverages Angular signals for reactive data handling
- Implements modern control flow (@let, @if) for template logic
- No complex lifecycle hooks or internal services
- Pipes are used for data transformation (booleanToValue, dateFormat)

API Reference:
  Exports:
    export class UserDetailsComponent {
      data = input.required<BaseUser | null>();
      protected userTypeNames = inject(USER_TYPE_NAMES);
    }

  Dependencies:
    - BaseUser interface from '@kebormed/x-kit/model'
    - USER_TYPE_NAMES token from '@kebormed/x-kit/tokens'
    - BooleanToValuePipe from '@kebormed/x-core/utils/pipes'
    - DateFormatPipe from '@kebormed/x-core/utils/pipes'

Best Practices and Gotchas:
- Do: Ensure USER_TYPE_NAMES token is provided in your application
- Do: Handle null data gracefully by checking the component's conditional rendering
- Do: Use this component for read-only user information display
- Don't: Expect any user interaction or editing capabilities
- Don't: Modify the component's styling directly; use the shared details.scss for consistency
- Don't: Pass undefined to the data input; use null instead

Migration Notes:
- v1.0.0: Initial release with modern Angular patterns
- Uses standalone component architecture (no NgModule required)
- Implements signal-based inputs instead of decorator-based @Input()

Related Components / Patterns:
- UserFormComponent: For editing user information
- UserListComponent: Uses this component to display expanded user details
- Similar detail components for other entities (PatientDetailsComponent, etc.)
- Follows the same pattern as other detail display components in the kit

Changelog:
- v1.0.0: Initial release with BaseUser display functionality

-----------------------------------------------------------

## File: ./projects/kit/user/user-form/user-form.txt

UserFormComponent - Component Documentation
Status: stable
Since: v1.1.0

Short description: A reusable form component for creating and editing user information with validation and support for both creation and edit modes.

Purpose and Overview:
The UserFormComponent provides a standardized form for creating and editing user information with comprehensive validation capabilities. It handles form validation including asynchronous validation for unique email and username, supports both creation and edit modes, and implements a responsive layout that adapts to different screen sizes. The component extends the BaseForm class and implements BaseFormAction interface to inherit common form functionality while providing specialized user management features. Key design decisions include automatic field disabling in edit mode for immutable fields (userType, username, email) and support for custom action templates via content projection.

Quick Start:
  Import:
    import { UserFormComponent } from '@kebormed/x-kit/user';
    import { CommonModule } from '@angular/common';

    @Component({
      selector: 'app-user-management',
      standalone: true,
      imports: [CommonModule, UserFormComponent],
      template: `
        <kbm-user-form
          [allowUserTypes]="[5, 6]"
          (save)="onSaveUser($event)"
          (edit)="onEditUser($event)">
        </kbm-user-form>
      `
    })
    export class UserManagementComponent {}

  Minimal usage (HTML):
    <kbm-user-form (save)="onSaveUser($event)"></kbm-user-form>

Inputs and Outputs:
- @Input() editData: BaseUser | null = null
  Description: Sets the form in edit mode with the provided user data. When set, certain fields (userType, username, email) become disabled to prevent changes to identifying fields.

- @Input() allowUserTypes: number[] = []
  Description: Filters the available user types in the dropdown to only show the specified types. Empty array shows all user types from USER_TYPES token.

- save: OutputEmitterRef<BaseUser>
  Description: Emitted when the form is submitted in create mode with the complete form value as BaseUser object. Uses modern output() function.

- edit: OutputEmitterRef<Partial<BaseUser>>
  Description: Emitted when the form is submitted in edit mode with the form value as partial BaseUser object. Uses modern output() function.

Slots and Content Projection:
The component supports content projection for custom form actions using the FormActionDirective. When no custom template is provided, default Submit and Reset buttons are displayed. Custom action templates receive the component instance as context.

Example:
<kbm-user-form>
  <ng-template kbmFormAction let-form>
    <button type="submit" [disabled]="!form.valid" kbm-button>Custom Submit</button>
    <button type="button" (click)="form.reset($event)" kbm-button>Custom Reset</button>
  </ng-template>
</kbm-user-form>

Styling and Theming:
- Uses flexbox layout with CSS container queries for responsive design
- Default layout adapts from 3 columns (large screens) to 2 columns (medium) to 1 column (small)
- Inherits shared form styles from '../../_shared/form.scss'
- Custom CSS properties available:
  * --form-layout-cols-lg: Number of columns for large screens (default: 3)
  * --form-layout-cols-md: Number of columns for medium screens (default: 2)
  * --form-layout-cols-sm: Number of columns for small screens (default: 1)
  * --gap: Gap between form fields (default: 16px)
- Host element has class 'kbm-form' applied automatically

Accessibility:
- Keyboard: Form fields are navigable using Tab key, Submit and Reset buttons are keyboard accessible
- ARIA: Uses standard form controls with proper labels for screen reader accessibility via kbm-label components
- Color contrast: Relies on underlying input components for proper WCAG compliance

Visual Examples:
Basic usage and variants:
  - Basic: Displays all user form fields (firstName, lastName, email, phone, username, userType) with submit/reset actions
  - Edit Mode: Same fields but with userType, username, and email disabled to prevent modification of identifying information
  - Custom Actions: Replaces default buttons with custom action template when FormActionDirective is provided
  - Filtered User Types: Shows only specified user types in dropdown when allowUserTypes is configured

Behaviors and Lifecycle:
The component extends BaseForm<BaseUser> and implements BaseFormAction interface. Form validation includes required field validation, email format validation, maximum length constraints, and asynchronous uniqueness validation for email and username. Uses OnPush change detection strategy for optimal performance. In edit mode, automatically disables immutable fields and stores previous values for reset functionality. User type dropdown is populated from injected USER_TYPES token and filtered based on allowUserTypes input. Modern Angular patterns include control flow (@if, @for), output() function for events, and standalone component architecture.

API Reference:
  Exports:
    export class UserFormComponent extends BaseForm<BaseUser> implements BaseFormAction

    Properties:
    - form: FormGroup with controls for firstName, lastName, email, phone, username, userType, isActive
    - _previousValue: Partial<BaseUser> - Stores previous form values for reset functionality
    - userTypes: IUserType - Injected USER_TYPES token for user type information

    Inputs:
    - editData: BaseUser | null - Sets form in edit mode with provided data
    - allowUserTypes: number[] - Filters available user types in dropdown

    Outputs (using modern output() function):
    - save: OutputEmitterRef<BaseUser> - Emitted on form submission in create mode
    - edit: OutputEmitterRef<Partial<BaseUser>> - Emitted on form submission in edit mode

    Content Child:
    - actionTemplate: FormActionDirective<{ $implicit: UserFormComponent }> - Template for custom form actions

    Methods:
    - userTypeFilter(item: KeyValue<string, UserType>, test: UserType[]): boolean - Filters user types
    - submit(): void - Handles form submission with @HostListener('submit')
    - reset(event: Event): void - Resets form to previous state with @HostListener('reset')

    Form Validation:
    - firstName: required, maxLength(32)
    - lastName: required, maxLength(32)
    - email: required, email format, uniqueEmail() async validator
    - phone: maxLength(24)
    - username: required, maxLength(32), uniqueUsername() async validator
    - userType: required
    - isActive: boolean (default: true)

Best Practices and Gotchas:
- Do: Use allowUserTypes input to restrict available user types based on current user permissions
- Do: Handle both save and edit events appropriately in parent component
- Do: Use FormActionDirective for custom form actions when default buttons don't meet requirements
- Do: Consider async validation states as email and username validation requires backend calls
- Don't: Modify editData input after it has been set, as it will not update form values
- Don't: Assume all fields are editable in edit mode; userType, username, and email are disabled
- Don't: Trigger form submission while async validators are still processing

Migration Notes:
Not applicable as this is the initial stable version of the component.

Related Components / Patterns:
- BaseForm from @kebormed/x-core/abstraction/form - Base class providing common form functionality
- FormActionDirective from @kebormed/x-core/components/form - Directive for custom form actions
- PhoneInputComponent from @kebormed/x-kit/components/phone-input - Used for phone number input
- BaseUser interface from @kebormed/x-kit/model - Data model for user information
- USER_TYPES token from @kebormed/x-kit/tokens - Injection token for user type information
- uniqueEmail, uniqueUsername validators from @kebormed/x-kit/validators - Async validators for uniqueness checking
- UserListComponent from @kebormed/x-kit/user - Often used together for user management workflows

Changelog:
- v1.1.0: Updated to use modern Angular patterns (output() function, control flow), enhanced validation with async validators, improved documentation
- v1.0.0: Initial release

-----------------------------------------------------------

## File: ./projects/kit/user/user-list/user-list.txt

UserListComponent - Component Documentation
Status: stable
Since: v1.0.0

Short description: A responsive user list component that displays user data in either a sortable table format or accordion format based on screen size.

Purpose and Overview:
The UserListComponent solves the problem of displaying user information in a responsive manner across different screen sizes. It extends the BaseTable class to provide sorting functionality and automatically switches between a table view for larger screens and an accordion view for smaller screens. The component is designed to handle BaseUser data and provides customizable action templates for user-specific operations. Key design decisions include the use of responsive design patterns, dependency injection for user type mapping, and content projection for flexible action handling.

Quick Start:
  Import:
    import { UserListComponent } from '@kebormed/x-kit/user';

    @Component({
      selector: 'app-demo',
      imports: [UserListComponent]
    })
    export class DemoComponent {}

  Minimal usage (HTML):
    <kbm-user-list [data]="users" (sort)="handleSort($event)"></kbm-user-list>

Inputs and Outputs:
- @Input() data: BaseUser[] = []
  Description: Array of user objects to display in the list. Each user should conform to the BaseUser interface from @kebormed/x-kit/model.

- @Output() sort: EventEmitter<SortEvt>
  Description: Emitted when user clicks on a sortable column header. Payload contains field name and sort direction information.

Slots and Content Projection:
The component supports action templates through the ActionTemplateDirective. Use the actionTemplate template reference to provide custom actions for each user row:

<kbm-user-list [data]="users">
  <ng-template #actionTemplate let-user>
    <button (click)="editUser(user)">Edit</button>
    <button (click)="deleteUser(user)">Delete</button>
  </ng-template>
</kbm-user-list>

Styling and Theming:
- No custom SCSS variables or CSS properties are exposed as the component relies on inherited styles
- Responsive behavior: Automatically switches to accordion layout on small screens using the isSmallScreen$ observable
- Composition tips: The component works well within card containers or as part of larger dashboard layouts
- Breakpoints: Uses the isSmallScreen$ service from @kebormed/x-kit/services for responsive behavior

Accessibility:
- Keyboard: Table columns support keyboard navigation and sorting via Enter/Space keys through ColumnSortDirective
- ARIA: Inherits ARIA roles and properties from the underlying KbmTable and KbmAccordion components
- Color contrast: Relies on the design system's color palette for WCAG compliance

Visual Examples:
Basic usage and variants:
  - Basic table view (desktop):
    Displays users in a sortable table with columns for First Name, Last Name, Username, Email, Role, Active status, Last Login, and Actions
  - Accordion view (mobile):
    Shows users as expandable accordion items with user details and actions within each item
  - With custom actions:
    Supports custom action buttons through template projection

Behaviors and Lifecycle:
The component extends BaseTable<BaseUser> which provides base table functionality. It uses OnPush change detection strategy for optimal performance. The isSmallScreen$ observable automatically triggers layout changes based on screen size. The mapUserType method converts numeric user type values to readable strings using the injected USER_TYPES token. The actionContext method provides proper typing for action template contexts.

API Reference:
  Exports:
    export class UserListComponent extends BaseTable<BaseUser>

  Dependencies:
    - BaseUser interface from @kebormed/x-kit/model
    - USER_TYPES token from @kebormed/x-kit/tokens
    - isSmallScreen$ service from @kebormed/x-kit/services
    - Various components from @kebormed/x-core/components
    - Utility pipes from @kebormed/x-core/utils/pipes

  Key Methods:
    - actionContext(data: unknown): ContextWithImplicit<BaseUser>
      Returns properly typed context for action templates
    - mapUserType(value: UserType): UserTypeKey
      Maps numeric user type to readable string using injected USER_TYPES

Best Practices and Gotchas:
- Do: Provide the USER_TYPES token at the appropriate level in your application
- Do: Use the BaseUser interface for type safety when passing data
- Do: Implement proper error handling for the sort event
- Do: Provide meaningful action templates for user operations
- Don't: Modify the data array directly; use immutable updates
- Don't: Forget to handle loading states when fetching user data
- Don't: Assume all BaseUser properties are always present; check for optional fields

Migration Notes:
- v1.0.0: Initial release - no migration needed

Related Components / Patterns:
- UserDetailsComponent: Used internally to display user information in accordion view
- BaseTable: Parent class providing table functionality
- KbmTable and KbmAccordion: Core UI components used for display
- BaseUser model from @kebormed/x-kit/model for data structure
- USER_TYPES token from @kebormed/x-kit/tokens for user type mapping

Changelog:
- v1.0.0: Initial release with responsive table/accordion layout and sorting support

-----------------------------------------------------------

## File: ./projects/kit/validators/validators.txt

Validators - Component Documentation
Status: stable
Since: v1.0.0

Short description: A collection of Angular form validators for validating user input and ensuring data integrity through synchronous date validation and asynchronous uniqueness checks.

Purpose and Overview:
The Validators module provides a set of custom Angular form validators that extend the built-in validation capabilities. These validators help ensure data integrity by validating dates and checking for uniqueness of various entity identifiers (email, username, tenant name, group name, serial number) against the backend. The module simplifies form validation by providing reusable validator functions that can be easily integrated with Angular's reactive forms. All async validators use dependency injection to access the ValidationService and only run when the control is dirty to minimize backend calls.

Quick Start:
  Import:
    import { validDate, uniqueEmail, uniqueUsername, uniqueSerialNumber, uniqueGroupName, uniqueTenantName } from '@kebormed/x-kit/validators';
    import { FormBuilder, Validators } from '@angular/forms';
    import { inject } from '@angular/core';

  Minimal usage (TypeScript):
    const createUserForm = () => {
      const fb = inject(FormBuilder);

      return fb.group({
        email: ['', [Validators.required, Validators.email], [uniqueEmail()]],
        username: ['', [Validators.required, Validators.minLength(3)], [uniqueUsername()]],
        birthDate: ['', [Validators.required, validDate()]]
      });
    };

Inputs and Outputs:
- validDate(): ValidatorFn
  Description: Synchronous validator that checks if a date is in the future (>= current time). Returns {date: true} if validation fails, null if valid.

- uniqueEmail(): AsyncValidatorFn
  Description: Asynchronous validator that checks email uniqueness against backend. Only runs when control is dirty. Uses ValidationService.isEmailUnique().

- uniqueUsername(): AsyncValidatorFn
  Description: Asynchronous validator that checks username uniqueness against backend. Only runs when control is dirty. Uses ValidationService.isUsernameUnique().

- uniqueSerialNumber(): AsyncValidatorFn
  Description: Asynchronous validator that checks device serial number uniqueness against backend. Only runs when control is dirty. Uses ValidationService.isSerialNumberUnique().

- uniqueGroupName(): AsyncValidatorFn
  Description: Asynchronous validator that checks group name uniqueness against backend. Only runs when control is dirty. Uses ValidationService.isGroupNameUnique().

- uniqueTenantName(): AsyncValidatorFn
  Description: Asynchronous validator that checks tenant name uniqueness against backend. Only runs when control is dirty. Uses ValidationService.isTenantNameUnique().

Slots and Content Projection:
Not applicable - these are validator functions, not components with templates.

Styling and Theming:
Not applicable - validators provide validation logic only, no visual styling.

Accessibility:
- Keyboard: Validators work with standard form controls and maintain keyboard accessibility
- ARIA: Validation errors should be announced to screen readers using appropriate ARIA attributes
- Color contrast: Error messages displayed based on validation results should meet WCAG compliance

Visual Examples:
Basic usage and variants:
  - Registration Form:
    Form with email and username fields using uniqueEmail() and uniqueUsername() validators
  - Tenant Creation:
    Form with tenant name field using uniqueTenantName() validator
  - Device Registration:
    Form with serial number field using uniqueSerialNumber() validator
  - Date Selection:
    Form with date field using validDate() validator for future dates

Behaviors and Lifecycle:
- Synchronous validators (validDate) execute immediately on value change
- Asynchronous validators only execute when control.dirty is true to minimize backend calls
- All async validators use asyncValidatorOperator from @kebormed/x-core/utils/validation
- Async validators return observables that emit validation results
- ValidationService is injected using the KBM_VALIDATION_SERVICE token
- Validators integrate with Angular's reactive forms validation lifecycle

API Reference:
  Exports:
    export function validDate(): ValidatorFn
    export function uniqueEmail(): AsyncValidatorFn
    export function uniqueUsername(): AsyncValidatorFn
    export function uniqueSerialNumber(): AsyncValidatorFn
    export function uniqueGroupName(): AsyncValidatorFn
    export function uniqueTenantName(): AsyncValidatorFn

  Dependencies:
    - @angular/forms (ValidatorFn, AsyncValidatorFn)
    - @angular/core (inject)
    - @kebormed/x-kit/services (KBM_VALIDATION_SERVICE, ValidationService)
    - @kebormed/x-core/utils/validation (asyncValidatorOperator)
    - rxjs (of)

Best Practices and Gotchas:
- Do: Use these validators with reactive forms for the best type safety and control
- Do: Remember that async validators only run when the control is dirty to minimize backend calls
- Do: Combine these validators with built-in Angular validators for comprehensive validation
- Do: Handle loading states during async validation, as backend calls may take time
- Don't: Use the validDate validator to check if a date is valid; it only checks if the date is in the future
- Don't: Forget to handle loading states during async validation
- Don't: Trigger form submission while async validators are still processing
- Don't: Assume validation will run on pristine controls for async validators

Migration Notes:
- v1.0.0: Initial release - no migration needed
- Note: The validDate validator has a TODO comment indicating it should be more specific about date validation

Related Components / Patterns:
- Angular Reactive Forms that use these validators
- Form components that display validation errors
- User registration and profile update flows
- Entity creation forms (tenants, groups, devices)
- ValidationService from @kebormed/x-kit/services
- asyncValidatorOperator from @kebormed/x-core/utils/validation

Changelog:
- v1.0.0: Initial release with validDate, uniqueEmail, uniqueUsername, uniqueSerialNumber, uniqueGroupName, and uniqueTenantName validators

-----------------------------------------------------------

